# Chapter 6

### 🤓 페이지 압축

- `Transparent Page Compression` 이라고 불린다.
- MySQL 서버가 디스크에 저장하는 시점에 `데이터 페이지`가 **압축되어 저장**되고, 디스크에서 `데이터 페이지`를 읽어올 때 **압축이 해제되는 방식**이다.

`버퍼 풀`에 데이터 페이지가 한 번 적재되면 `InnoDB 스토리지 엔진`은 압축이 해제된 상태로만 

데이터 페이지를 관리한다.

`16KB` 데이터 페이지를 압축한 결과가 용량이 얼마나 될지 **예측이 불가능**한데 적어도 하나의 테이블은

`동일한 크기`의 페이지(블록)로 통일되어야 한다는 문제가 있다.

이런 문제로 인해 `페이지 압축` 기능은 운영체제별로 특정 버전의 파일 시스템에서만 지원되는 `펀치 홀`이라는

기능을 사용하고 있다.

`운영체제(파일 시스템)`의 **블록 사이즈가 512바이트**인 경우, `페이지 압축`이 작동하는 방식은 아래와 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/a61a2943-bd96-4f36-aa4a-51d9406dfe16)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/05a34df7-12d8-40fe-8831-a55e9cf7b533)

오른쪽 그림은 `16KB` 페이지에 대해 `9KB` 만큼 **펀치 홀이 생성**된 것을 의미한다.

이 상태에서는 `실제 디스크`의 공간은 `7KB`만 차지한다.

운영체제에서 `16KB`를 읽으면 압축된 데이터 `7KB`와 펀치 홀 공간인 `9KB`를 합쳐서 `16KB`를 읽는다.

`MySQL` 서버의 페이지 압축이 가진 문제는 `펀치 홀` 기능은 `운영체제`뿐만 아니라 `하드웨어` 자체에서도

**해당 기능을 지원해야 사용 가능**하다는 점이다.

**파일 시스템 관련 명령어**가 `펀치 홀`을 지원하지 못한다는 `문제`도 남아있다.

`cp`와 같은 파일 복사 명령을 사용하면 **데이터 파일의 크기는 원본 크기**로 돌아올 수 있다.

이런 `문제점` 때문에 **실제 페이지 압축은 많이 사용되지 않는 상태**다.

`페이지 압축`을 이용하기 위해서는 **테이블을 생성**하거나 **변경**할 때 `COMPRESSION` 옵션을 주면 된다.

```sql
-- 테이블 생성시
mysql> CREATE TABLE t1 (c1 INT) COMPRESSION="zlib";

-- 테이블 변경시
mysql> ALTER TABLE t1 COMPRESSION="zlib";
mysql> OPTIMIZE TABLE t1;
```

### 😐 테이블 압축

- `테이블 압축`은 **운영체제나 하드웨어에 대한 제약 없이 사용**할 수 있다.
- `테이블 압축`은 **디스크의 데이터 파일 크기를 줄일 수 있다는 장점**이 있다.

물론, `테이블 압축`도 **몇 가지 단점이 존재**한다.

- 버퍼 풀 공간 활용률이 낮다.
- 쿼리 처리 성능이 낮다.
- 빈번한 데이터 변경 시 압축률이 떨어진다.

### 🥱 압축 테이블 생성

- `테이블 압축`을 사용하려면 압축을 사용하려는 `테이블`이 별도의 `테이블 스페이스`를 사용해야 한다.
- `innodb_file_per_table` 시스템 변수가 `ON`으로 설정된 상태에서 테이블이 생성돼야 한다.

`테이블 압축`을 사용하는 테이블은 `ROW_FORMAT=COMPRESSED` 옵션을 명시해야 한다.

추가로 `KEY_BLOCK_SIZE` 옵션을 이용해 압축된 페이지의 `타깃 크기`를 명시할 수 있는데,

`2n(n ≥ 2)`으로만 그 값을 설정할 수 있다.

`InnoDB` 스토리지 엔진의 페이지 크기가 `16KB`라면 `KEY_BLOCK_SIZE`는 **4KB 또는 8KB만 설정**할 수 있다.

`페이지 크기`가 **32KB 이거나 64KB인 경우에는 테이블 압축을 적용할 수 없다.**

`압축 테이블`을 생성하려면 아래 **예시의 명령**으로 할 수 있다.

```sql
mysql> SET GLOBAL innodb_file_per_table=ON;

-- ROW_FORMAT 옵션과 KEY_BLOCK_SIZE 옵션을 모두 명시
mysql> CREATE TABLE compressed_table (
         c1 INT PRIMARY KEY,
         )
         ROW_FORMAT=COMPRESSED,
         KEY_BLOCK_SIZE=8;
         
-- KEY_BLOCK_SZIE 옵션만 명시
mysql> CREATE TABLE compressed_table (
        c1 INT PRIMARY KEY
       )
       KEY_BLOCK_SIZE=8;
```

`ROW_FORMAT` 옵션이 생략되면 자동으로 `ROW_FORMAT=COMPRESSED` 옵션이 추가 되어 생성된다.

`KEY_BLOCK_SIZE`에 명시된 옵션값은 `KB 단위`를 설정한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d0ae58c2-fc5d-4e16-90f3-9ea24c483763)

`InnoDB 스토리지 엔진`이 **압축을 적용하는 과정**을 간단히 살펴보자.

`스토리지 엔진`의 **데이터 페이지의 크기는 16KB**, **KEY_BLOCK_SIZE는 8**로 `설정`되었다고 `가정`한다.

`데이터 페이지`를 압축한 용량이 얼마가 될 지 알 수 없는데 어떻게 `KEY_BLOCK_SIZE`를

`테이블`을 생성할 때 설정할 수 있었을까?

1. `16KB`의 데이터 페이지를 압축한다.
    1. 압축된 결과가 `8KB 이하`이면 **그대로 디스크에 저장(압축 완료)**
    2. 압축된 결과가 `8KB를 초과`하면 **원본 페이지를 스플릿(Split)**해서 `2`개의 페이지에 `8KB`씩 저장
2. `나뉜 페이지` 각각에 대해 **1번 단계를 반복 실행**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/801f889b-c2a2-463a-815b-3d8694b68821)

이 그림에서 알 수 있는 사실은 두 가지다.

- `InnoDB` 스토리지 엔진의 **InnoDB I/O 레이어에서는 아무런 역할을 하지 않는다.**
- `원본 데이터 페이지`의 압축 결과가 `목표 크기`보다 작거나 같을 때까지 **반복해서 페이지가 스플릿**된다.

이로 인해 알 수 있는 `중요한 사실`은, 목표 크기가 잘못 설정되면 `MySQL 서버`의 처리 성능이 급격히

떨어질 수 있다는 점이다.

### 🫠 KEY_BLOCK_SIZE 결정

- `테이블 압축`에서 가장 중요한 부분은 `KEY_BLOCK_SIZE`의 크기를 결정하는 것이다.
- `테이블 압축`을 적용하기 전에 `4KB` 또는 `8KB`로 테이블을 생성해서 `샘플 데이터`를 저장해보고 판단하는 것이 좋다.
- 최소한 테이블의 `데이터 페이지`가 `10개` 정도는 생성되도록 **INSERT 작업**을 해보는 것이 좋다.

`employees` 테이블을 이용해서 `KEY_BLOCK_SIZE`를 선택하는 예제를 따라해보자.

1. 먼저 `employees`와 같은 구조를 가지는 `테이블을 생성`한다(KEY_BLOCK_SIZE=4)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/dde91a1e-9b7f-469d-a34b-ebdb144e7f15)

2. `테스트`를 실행하기 전에 `인덱스`별로 **압축 실행 & 성공 횟수가 기록**되도록 시스템 변수를 `ON` 해준다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/5596562e-1bbb-4512-ae94-a128c3cdca34)

3. `employees` 테이블의 데이터를 그대로 `압축 테스트 테이블`로 저장한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/24c7cf2d-a57c-460d-85bd-d48e7a4b295d)

4. `인덱스별`로 **압축 횟수와 성공 횟수, 압축 실패율**을 조회한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/6238ffb0-37a3-4f11-b439-9bed73f76dad)

`조회 결과`를 보면서 **압축 성공과 실패율**을 살펴보자.

`PRIMARY KEY`는 전체 `18653`번 압축을 실행하고 `13478`번 성공했다.

즉 `압축의 결과`가 **4KB를 초과**해서 `데이터 페이지`를 스플릿해서 다시 `압축`을 `실행`했다는 의미다.

`PRIMARY KEY`의 압축 실패율은 **27.67%**이고 나머지 인덱스도 `압축 실패율`이 상대적으로 높다.

일반적으로 **압축 실패율은 3~5% 미만으로 유지**되는 것이 좋다.

그렇다면 이번에는 `KEY_BLOCK_SIZE`를 `8KB`로 늘려서 테스트를 실행해보자.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/79747c9c-3fa0-4030-b769-16bae89f91d2)

`KEY_BLOCK_SIZE`를 두 배로 늘렸지만 생각보다 `압축 실패율`이 높은 것을 볼 수 있다.

이 결과를 기준으로 판단하면 `압축 실패율`이 높아서 `InnoDB` 버퍼 풀에서 디스크로 기록되기 전에 압축하는 

과정이 **꽤 오랜 시간이 걸릴 것이라고 판단**할 수 있다.

`압축 실패율`이 높다고 해서 실제 `디스크`의 데이터 파일 크기가 줄어들지 않는다는 의미는 아니다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/7a44df68-22a9-46f8-8e74-979b618f2887)

**압축을 하지 않은 테이블**은 테이블 크기가 `30MB`이고,

`4KB 압축`을 적용한 테이블은 **20MB**, `8KB` 압축을 적용한 테이블은 **21MB** 용량을 가진다.

이렇게 차이가 별로 나지 않는 경우에는 `압축 실패율`은 낮으면서 `압축 효율`이 좋은 **8KB를 선택**해야 한다.

여기서 주의해야 할 점은 `압축 실패율`이 높다고 해서 `압축`을 사용하지 말아야 한다는 것은 아니다.

`INSERT` 작업만 있는 테이블은 압축 시도가 실패해서 `페이지 스플릿`이 일어나도 큰 손해는 아닐 것이다.

반면에 빈번하게 조회되고 변경되는 `테이블`이라면 압축을 고려하지 않는 것이 좋다.

`테이블 압축`에는 `zlib`이 사용되는데, 이 **압축 알고리즘은 CPU 자원을 많이 소모**한다는 것을 기억하자.

### ☺️ 압축된 페이지의 버퍼 풀 적재 및 사용

- `InnoDB 스토리지 엔진`은 압축된 테이블의 `데이터 페이지`를 버퍼 풀에 적재하면 **압축된 상태와 압축이 해제 된 상태 2개 버전을 관리**한다.
- `InnoDB 스토리지 엔진`은 디스크에서 읽은 상태 그대로의 `데이터 페이지 목록`을 관리하는 **LRU 리스트**와 압축된 페이지들의 `압축 해제 버전`인 **Unzip_LRU 리스트를 별도로 관리**한다.

`MySQL 서버`는 압축된 테이블과 압축되지 않은 테이블이 공존하기 떄문에 `LRU 리스트`는 

아래와 같이 `압축된 페이지`와 `압축되지 않은 페이지`를 모두 가질 수 있다.

- `압축`이 적용되지 않은 테이블의 `데이터 페이지`
- `압축`이 적용된 테이블의 압축된 `데이터 페이지`

`Unzip_LRU` 리스트는 압축이 적용되지 않은 테이블의 `데이터 페이지`는 가지지 않고,

`압축이 적용된 테이블`에서 읽은 **데이터 페이지만 관리**한다.

`InnoDB 스토리지 엔진`은 압축된 테이블에 대해서 `버퍼 풀의 공간`을 이중으로 사용하기 때문에

**메모리를 낭비**하게 된다.

또 다른 문제점으로는 `압축된 페이지`에서 데이터를 읽거나 변경하기 위해서는

`압축`을 해제해야 한다는 점이 있는데, `압축` 및 `압축 해제 작업`은 **CPU 자원을 많이 소모**한다.

이런 단점을 보완하기 위해서 `Unzip_LRU` 리스트를 별도로 관리하고 있다가,

`MySQL 서버`로 유입되는 `요청 패턴`에 따라서 적절히 **아래와 같은 처리를 수행**한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/820ba2d7-1393-4ae2-95fc-a30ea2f7eed8)

`InnoDB 스토리지 엔진`은 버퍼 풀에서 압축 해제된 버전의 `데이터 페이지`를 적절한 수준으로 

유지하기 위해서 `Adaptive(적응적인)` 알고리즘을 사용한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/b848bffb-6b9e-4f82-998a-b6a74d6d005c)


### ☺️ 테이블 압축 관련 설정

- `테이블 압축`을 사용할 때 연관된 `시스템 변수`가 몇 가지 있다.
- 모두 페이지의 `압축 실패율`을 낮추기 위해 필요한 `튜닝 포인트`를 `제공`한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9a464911-701c-4cef-9502-01743f0c7d2c)
![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/998a2621-c4bb-4084-8b4b-fff1a94d203f)
