# 04 아키텍처

MySQL = MySQL 엔진(머리) + 스토리지 엔진(손발)

스토리지 엔진은 핸들러 API만 만족하면 구현해서 사용가능하다. → 무슨 말일까?

## 4.1 MySQL 엔진 아키텍처

MySQL은 다른 DBMS와 달리 `독특한 구조`를 가지고 있다. 이는 혜택이 되기도, 문제가 되기도 한다. 

### 4.1.1 MySQL의 전체 구조

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/ccf25032-e492-4a7b-9b73-a38c526ab08d)


MySQL은 프로그래밍 언어로부터 접근 방법을 지원한다. JDBC와 같은 표준 드라이버 등이 그것이며, 이 드라이버를 이용해 MySQL 서버에서 쿼리를 사용할 수 있다. 

앞으로는 MySQL 쿼리파서, 옵티마이저 등의 기능을 스토리지 엔진과 구분할 것이고, 스토리지 엔진과 MySQL엔진을 합쳐서 MySQL(서버)라고 한다. 

**4.1.1.1 MySQL 엔진**

역할

- SQL 문장 분석, 최적화 등 DBMS의 두뇌

구성

- 커넥션 핸들러
    - 클라이언트로부터의 접속 및 쿼리 요청을 처리
- SQL 파서 및 전처리기
- 옵티마이저
    - 쿼리의 최적화된 실행 담당

MySQL은 표준 SQL(ANSI SQL)을 지원해 타 DBMS와 호환되어 실행가능하다. 

**4.1.1.2 스토리지 엔진**

역할

- 실제 데이터를 디스크 스토리지에 저장
- 디스크 스토리지로부터 데이터를 읽기

특징

- 하나만 있는 MySQL 엔진과 달리 여러 개를 동시에 사용 가능
- 테이블마다 사용할 스토리지 엔진 지정 가능
    
    ```sql
    mysql> CREATE DATABASE real_mysql; // 데이터베이스 생성
    mysql> USE DATABASE real_mysql;    // 데이터베이스 선택
    
    mysql> CREATE TABLE test_table (fd1 INT, fd2 INT) **ENGINE=INNODB**;
    ```
    ![image](https://github.com/only-juun/real-mysql-study/assets/79013722/c04a5abe-fd4a-4cf5-bbf3-015f1b481bc4)

    
    데이터베이스 선택을 안하면 아래와 같은 에러 발생
    
- 각 스토리지 엔진은 성능 향상을 위해 `키 캐시`나 `InnoDB 버퍼 풀` 같은 기능을 내장하고 있음

**4.1.1.3 핸들러 API**

`핸들러 요청`이란 `MySQl 엔진의 쿼리 실행기에서` 데이터 읽기/쓰기에 대해 `스토리지 엔진에` 보내는 요청을 의미한다. 이 때 사용되는 API가 `핸들러 API` 이다. 

MySQL 엔진과 스토리지 엔진이 데이터를 주고받는 방법이 핸들러 API인 것이다.

얼마나 많은 데이터(레코드) 작업이 있었는지 알아보는 명령은 아래와 같다.

```sql
mysql> SHOW GLOBAL STATUS LIKE 'Handler%';
```

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/7e81d2d4-f9a1-41e7-af77-57b7e08f4bc4)

                                                  <아무것도 하지 않았는데 뭐가 이리 많을까?>

### 4.1.2 MySQL 스레딩 구조

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/56090e4b-5c71-422a-9b66-9d47a57b52d3)


`MySQL`은 프로세스 기반이 아니라 `스레드 기반`이다.

`Foreground Thread`와 `Background Thread`로 구분할 수 있다.

MySQL에서 실행 중인 스레드 목록은 performance_schema DB의 threads 테이블에서 확인할 수 있다.

```sql
mysql> SELECT thread_id, name, type, processlist_user, processlist_host
			 FROM performance_schema.threads ORDER BY type, thread_id;
```

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/ab7b2c8d-b2ae-492a-a9af-416e1dbeec1f)


3개의 foreground Thread를 제외한 나머지는 모두 background thread이다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/6827ad9f-b3b1-4aac-b7ea-61e01c634627)


책에서는 스레드가 총 44개지만 나는 38개 

→ `백그라운드 스레드의 개수`는 MySQL 서버의 설정 내용에 따라 `가변적`이기 때문

- 동일한 이름의 스레드가 존재한다면 설정에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 것

 `thread/sql/one_connection` 스레드만 실제 `사용자에게 요청을 처리하는 foreground thread`이다.

**4.1.2.1 포그라운드 스레드(클라이언트 스레드)**

`포그라운드 스레드`는 최소한 `클라언트 수만큼` 존재하고, 각 클라이언트가 요청하는 `쿼리문을 처리한`다.

클라이언트가 `커넥션을 종료`하면 해당 스레드는 `스레드 캐시(Thread cache)`로 되돌아간다. 스레드 캐시에 대기 중인 스레드가 일정 개수(`thread_cahce_size`)에 도달한 상태라면 `스레드를 종료`시킨다. 

포그라운드 스레드는 `데이터를 데이터 버퍼나 캐시로부터` 가져오고, 거기에 없을 경우 `직접 디스크의 데이터나 인덱스 파일로부터` 가져와 처리한다. 

- MyISAM 테이블
    - 디스크 쓰기 작업까지 모두 포그라운드 스레드가 처리
- InnoDB 테이블
    - 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리
    - 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리

**4.1.2.2 백그라운드 스레드(P.83)** 

InnoDB의 경우 다음 작업들이 백그라운드로 처리된다.

- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- `로그 스레드(Log thread)` - 중요
    - 로그를 디스크로 기록하는 스레드
- `쓰기 스레드(Write thread)` - 중요
    - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
    - 아주 많은 작업을 담당
        - 일반적인 내장 디스크 사용 시: 2~4개
        - DAS, SAN 등의 스토리지 사용 시: 디스크를 최적으로 사용할 수 있을 만큼의 개수
- 읽기 스레드(Read thread)
    - 데이터를 버퍼로 읽어 오는 스레드
    - 읽기 작업은 주로 클라이언트(포그라운드)에서 처리되기 때문에 많이 필요 없음
- 잠금이나 데드락을 모니터링하는 스레드

5.5부터 데이터 쓰기, 읽기 스레드를 2개 이상 지정이 가능하며, innodb_write_io_threads,  innodb_read_io_threads로 개수를 설정한다. 

사용자의 요청을 처리하는 도중 `쓰기 작업은 지연(버퍼링)이 가능`하지만, `읽기 작업은 절대 지연될 수 없다`.

그래서 InnoDB는 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있다. 

→ INSERT, UPDATE, DELETE 쿼리로 데이터 변경 시 완전히 저장될 때까지 기다릴 필요가 없다.

반면에 MyISAM은 사용자 스레드가 쓰기 작업까지 함께 처리되도록 설계되어 있다.

→ 일반적인 쿼리는 쓰기 버퍼링 기능을 사용 불가하다.

### 4.1.3 메모리 할당 및 사용 구조

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/1670f61e-b9a8-4f63-b5b7-04f85462e6ae)


MySQL의 메모리 공간은 `글로벌 메모리 영역`과 `로컬 메모리 영역`으로 구분할 수 있다. 

글로벌 메모리 영역의 모든 메모리 공간은 서버 시작 시 `운영체제로부터 할당`된다. 운영체제마다 메모리 할당 방식이 달라 복잡하기 때문에 서버가 사용하는 메모리 양 측정도 어렵다. 시스템 변수 설정값만큼 할당받는다고 생각하면 쉽다. 

로컬 메모리 영역과 구분하는 기준은 `서버 내에 존재하는 많은 스레드가 공유해서 사용하는지 여부`이다.

**4.1.3.1 글로벌 메모리 영역**

`클라이언트 스레드 수와 무관`하게 하나의 메모리 공간만 할당된다. 필요에 따라 2개 이상의 공간을 할당받았다고 하더라도 `모든 스레드에 의해 공유`된다. 

대표적인 글로벌 메모리 영역

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

**4.1.3.2 로컬 메모리 영역**

`세션 메모리 영역`, `클라이언트 메모리 영역`이라고도 하며, `클라이언트 스레드가 쿼리를 처리`하기 위해 사용하는 메모리 영역이다. 

대표적인 로컬 메모리 영역

- 커넥션 버퍼
- 정렬 버퍼
- 조인버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

클라이언트가 서버에 접속하면 요청 처리를 위해 클라이언트 커넥션으로부터 스레드를 하나씩 할당 받는다. 로컬 메모리는 스레드별로 `독립적으로 할당`되고 절대 `공유되지 않는다`. 

또한, 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 그렇지 않은 경우는 MySQL이 할당조차 하지 않을 수 있다. 

- 커넥션이 열려 있는 동안 계속 할당된 상태로 유지: 커넥션 버퍼, 결과 버퍼
- 쿼리를 실행하는 순간에만 할당, 다시 해제: 소트 버퍼, 조인 버퍼

### 4.1.4 플러그인 스토리지 엔진 모델(P.86)

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/788a20e1-c88e-4ccb-a3b6-6fac4c194c43)


MySQL의 독특한 구조 중 하나가 `플러그인 모델`이다. 

`스토리지 엔진`,아니라 전문 검색 엔진을 위한 `검색어 파서`, `사용자 인증`(Native Authentication, Caching SHA-2 Authentication)도 플러그인으로 사용할 수 있다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/51fcf703-c8a6-40e8-b26f-5b9ba3be3e30)


MySQL에서 쿼리가 실행되는 과정이다.

대부분은 MySQL 엔진에서 처리되고, 데이터 읽기/쓰기만 스토리지 엔진에서 처리된다. 

이 과정에서 `핸들러(Handler)`가 등장한다. 

`MySQL 엔진이 사람`이고, `스토리지 엔진이 자동차`라면 자동차를 운전하는 `운전대가 핸들러`이다.

*MySQL 엔진이 스토리지 엔진에게 데이터에 대해 명령하려면 반드시 핸들러를 통해야 한다.*

스토리지 엔진이 달라도 쿼리에 대한 MySQL의 처리 내용은 대부분 동일하며, 데이터 읽기/쓰기 영역의 처리만 차이가 있다. 

복잡한 처리는 스토리지 엔진이 아닌 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리된다.

하지만 이게 스토리지 엔진을 뭘 쓰든 별 차이 없다는 것을 의미하는 것은 아니다. 

*하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 어디(MySQL 엔진 vs 스토리지 엔진)에서 처리되는지 구분할 줄 알아야 한다.*

```sql
mysql> SHOW ENGINES;
```

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/b38cc4b5-6c45-42e3-a37c-482589d5e1c9)


MySQL 서버에서 지원되는 스토리지 엔진은 위와 같으며, Support 칼럼의 값의 의미는 아래와 같다.

- YES: 해당 스토리지 엔진 포함 중, 사용 가능으로 활성화된 상태
- DEFAULT: YES와 동일 + 필수 스토리지 엔진
- NO: 포함되지 않았음
- DISABLED: 포함되었지만 파라미터에 의해 비활성화된 상태

NO를 사용하려면 MySQL 서버를 다시 빌드하거나, 플러그인 형태로 다운로드해서 사용해야 한다. 

```sql
mysql> SHOW PLUGINS;
```

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/a79f067d-9156-4e0a-88aa-eeb4fb9b67ac)


플러그인들을 확인할 수 있으며 자세한 정보는 매뉴얼을 참조하면 된다.

### 4.1.5 컴포넌트

기존의 플러그인 아키텍처는 단점이 존재한다.

- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신 불가
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출 → 안전하지 않음(캡슐화 안 됨)
- 플러그인은 상호 의존 관계를 설정 불가 → 초기화가 어려움

이를 보완하기 위해 8.0부터는 `컴포넌트 아키텍처`가 지원된다. 

```sql
-- // validate_password 컴포넌트 설치
mysql> INSTALL COMPONENT 'file://component_validate_password';

-- // 설치된 컴포넌트 확인
mysql> SELECT * FROM mysql.component;
```

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/0d94103c-cadc-4eb9-b94a-e8fe5dee1280)


### 4.1.6 쿼리 실행 구조

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/c00e06b4-86bf-4c86-b3e3-c195f4f0f199)


**4.1.6.1 쿼리 파서**

사용자 요청으로 들어온 `쿼리 문장`을 `토큰으로 분리`해 `트리 형태의 구조`로 만들어 내는 작업을 의미한다.

여기서 토큰이란 MySQL이 인식할 수 있는 최소 단위의 어휘나 기호이다.

쿼리 문장의 `기본 문법 오류`는 이 과정에서 발견되어 사용자에게 오류 메시지를 전달한다. 

**4.1.6.2 전처리기**

파서 트리를 기반으로 쿼리 문장에 `구조적인 문제점이 있는지 확인`한다. 

각 토큰을 테이블 이름, 칼럼 이름, 내장 함수같은 개체에 매핑하여 해당 `객체의 존재 여부`와 `객체의 접근 권한` 등을 확인한다. 존재하지 않거나 권한이 없는 개체의 토큰이 걸러지는 단계이다.

**4.1.6.3 옵티마이저(중요)**

쿼리 문장을 `저렴한 비용으로 가장 빠르게 처리할지를 결정`하는 역할을 하며 `DBMS의 두뇌`와 같다.

**4.1.6.4 실행 엔진**

옵티마이저는 경영진, 실행 엔진은 중간 관리자, 핸들러는 실무자라고 볼 수 있다. 

옵티마이저가 GROUP BY를 위해 임시 테이블을 사용하기 결정한 상황을 가정해보자.

1. `실행 엔진이 핸들러에게` 임시 테이블을 만들라고 `요청`
2. 다시 `실행 엔진은` WHERE 절에 일치하는 레코드를 읽어오라고 `핸들러에게 요청`
3. 읽어온 레코드들을 1 번에서 준비한 임시 테이블로 저장하라고 다시 `핸들러에게 요청`
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 `핸들러에게 다시 요청`
5. 최종적으로 `실행 엔진은 결과를 사용자나 다른 모듈로 넘김`

**4.1.6.5 핸들러(=스토리지 엔진)**

MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 `데이터를 디스크로 저장/디스크에서 읽어오는 역할`이다. 즉, `스토리지 엔진`을 의미한다. 

### 4.1.7 복제

복제(Replication)는 매우 중요하다. 별도의 챕터에서 자세히 살펴보자.

### 4.1.8 쿼리 캐시

8.0에서 `쿼리 캐시는 완전히 제거`되었다. 읽기만 많은 특정 환경에서는 매우 훌륭한 기능이지만 동시 처리 성능 저하 등의 문제가 크게 작용했다. 

### 4.1.9 스레드 풀(P.93)

스레드 풀(Thread Pool)은 엔터프라이즈 에디션은 지원하지만 커뮤니티 에디션은 지원하지 않는다.

Percona Server에서 제공하는 스레드 풀 기능을 살펴보자.

스레드 풀은 동시에 처리되는 요청이 많더라도 MySQL 서버의 CPU가 `제한된 개수의 스레드 처리에만 집중`할 수 있도록 하여, `서버의 자원 소모를 줄이는 것`을 목적으로 합니다. 하지만 실제로 눈에 띄는 성능 향상을 보여준 경우는 드물다. 또한 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못한다면 쿼리 처리가 느려질 수도 있다. 

물론 적절하게 처리한다면 CPU의 프로세서 친화도도 높이고 불필요한 컨텍스트 스위치도 줄여서 오버헤드를 낮출 수 있다.

Percona Server의 스레드 풀은 기본적으로 CPU 코어 수만큼 스레드 그룹을 생성한다. MySQL 서버가 처리해야 할 요청이 생기면 `스레드 풀로 처리를 이관`하고, 이미 스레드 풀이 처리 중인 작업이 있다면 `thread_pool_oversubscribe` 시스템 변수에 설정된 개수만큼 추가로 더 받아서 처리한다. 시스템 변수 값이 너무 크면 스케줄링 할 스레드가 많아져 비효율적이게 될 수 있다. 

스레드 그룹의 모든 스레드가 일하는 중일 때 요청이 들어오면 선택지는 두 개이다. 

1. 스레드 그룹에 `새로운 작업 스레드`(Wroker thread) 추가
2. 기존 작업 스레드의 `처리 완료 대기`

이를 판단하는 것이 스레드 풀의 `타이머 스레드`다. 스레드 그룹의 상태를 체크해서 `thread_pool_stall_limit` 보다 작업이 오래 걸린다면 새 스레드를 생성한다. 이는 새로운 쿼리 요청이 들어오면 `thread_pool_stall_limit` 시간 동안은 기다려야 요청을 처리할 수 있다는 뜻이기도 하다. 응답시간에 민감한 서비스라면 적절히 낮춰야 하지만 0에 가까운 값은 권장하지 않는다. 그 정도라면 스레드 풀을 사용하지 않는 것이 낫다.

`선순위 큐/후순위 큐 기능`을 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수도 있다. 먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고 잠금 경합을 낮춰서 전체적인 처리성능을 향상시킬 수 있다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/8fc1c246-87a3-4d6d-84d3-9cacdaee6588)


### 4.1.10 트랜잭션 지원 메타데이터

`데이터 딕셔너리` 또는 `메타데이터`는 데이터베이스 서버에서 `테이블 구조 정보`와 `스토어드 프로그램 등의 정보`를 뜻한다. 

5.7까지는 이를 `파일 기반`으로 관리했다. 파일 기반의 메타데이터는 생성 및 변경 작업이 `트랜잭션을 지원하지 않아` 생성 및 변경 도중 MySQL 서버가 비정상 종료되면 `일관되지 않은 상태`(DB나 테이블이 깨진 상태)로 남는 문제가 생긴다.

8.0부터는 이를 해결하기 위해 `InnoDB의 테이블`을 사용한다. 시스템 테이블을 모두 InnoDB 스토리지 엔진을 사용하도록 개선되었고, 시스템 테이블과 메타데이터를 모아 `mysql DB에 저장`한다. mysql DB는 `mysql.ibd`라는 이름의 테이블 스페이스에 저장된다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/bc722fe2-1ff9-4e80-a4e1-833cd8b73cc6)


![image](https://github.com/only-juun/real-mysql-study/assets/79013722/813d2827-abf1-44d8-b4ed-ac36b633e398)


데이터 딕셔너리와 시스템 테이블이 모두 `트랜잭션 기반의 InnoDB 스토리지
엔진에 저장`되면서 비정상 종료 시에도 원자성이 유지된다.

`MylSAM`이나 `CSV` 등과 같은 `InnoDB 스토리지 엔진 이외의 스토리지 엔진`을 사용하는 테이블들은 `SDI(Serialized Dictionary Information) 파일`을 사용한다. *.sdi 파일로 존재하며 InnoDB 테이블의 구조 또한 SDI 파일로 변환이 가능하다. 

## 4.2 InnoDB 스토리지 엔진 아키텍처(P.98)

InnoDB는 스토리지 엔진 중 거의 유일하게 `레코드 기반의 잠금`을 제공한다. 덕분에 높은 동시성 처리와 안정성, 성능 모든 면에서 우수하다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/14573f07-0419-43f7-8c64-373e5b6864b0)


### 4.2.1 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 `프라이머리 키를 기준으로 클러스터링`되어 저장된다. 

프라이머리 키가 클러스터링 인덱스이므로 프라이머리 키를 이용한 `레인지 스캔이 상당히 빠르다`. 덕분에 쿼리의 실행 계획에서 프라이머리 키는 다른 보조 인덱스 보다 비중이 높아 먼저 선택될 가능성이 높다. 

모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키 값을 논리적인 주소로 사용한다. 

MyISAM 스토리지 엔진은 클러스터링 키를 지원하지 않는다. 그래서 프라이머리 키와 세컨더리 인덱스는 구조적으로 차이가 없다. 즉, 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐인 것이다. 

MyISAM 테이블의 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)을 가진다. 

### 4.2.2 외래 키 지원

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능이다. 데이터베이스 서버 운영의 불편함을 이유로 서비스용 데이터베이스에 외래 키를 생성하지 않는 경우도 많지만, 개발 환경 데이터베이스에서는 좋은 가이드 역할을 한다. 

외래 키는 부모 테이블, 자식 테이블 모두 인덱스 생성이 필요하고, 변경 시에는 반드시 모두에 데이터가 있는지 체크해야 해서 `잠금이 여러 테이블에 전파`된다. 이로 인해 `데드락이 많이 발생`하므로 외래 키 존재에 주의해야 한다.

외래 키가 복잡하게 얽힌 경우에는 작업이 어려워진다. foreign_key_checks 변수를 OFF로 설정하여 쉽게 갈 수도 있지만 결국은 데이터 일관성을 맞추는 작업이 있어야 한다. 

### 4.2.3 MVCC(Multi Version Concurrency Control)

MVCC는 `잠금을 사용하지 않는 일관된 읽기를 제공`하는데 가장 큰 목적이 있다. InnoDB는 언두 로그(Undo Log)를 이용해 이 기능을 구현한다. 

`Multi-Version`의 의미는 `하나의 레코드에 대해 여러 개의 버전이 동시에 관리`됨을 의미한다. 

- [격리 수준](https://n1tjrgns.tistory.com/267)
    
    트랜잭션을 사용할 때, 전파레벨과 함께 따라오는 것이 `격리수준`이다. 트랜잭션에서 `일관성이 없는 데이터를 허용하도록 하는 수준`을 말한다. 격리수준에는 `4가지`가 있다.
    
    - READ_UNCOMMITED (level 0)
    - READ_COMMITED (level 1)
    - REPEATABLE_READ (level 2)
    - SERIALIZABLE (level 3)
    
    격리 수준이 높아질수록 동시성(Concurrency)은 높아지고 속도는 느려진다. 이 둘의 `균형`을 잘 맞추는것이 중요하다.
    

격리 수준(Isolation level)이 `READ_COMMITTED`인 MySQL 서버에서
InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 살펴보자. 

```sql
mysql> USE real_mysql;

mysql> CREATE TABLE member (
				m_id INT NOT NULL,
				m_name VARCHAR(20) NOT NULL,
				m_area VARCHAR(100) NOT NULL,
				PRIMARY KEY (m_id),
				INDEX ix_area (m_area)
			);

mysql> INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
mysql> COMMIT;
```

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/73a8f11b-0117-4147-9a41-a09675335123)


레코드를 삽입하고 COMMIT 했을 때 데이터베이스의 상태는 아래와 같다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/cdf68551-47f2-4225-89a4-00e38a071afe)


```sql
mysql> UPDATE member SET m_area='경기' WHERE m_id=12;
```

레코드를 업데이트하면 데이터베이스는 아래와 같은 상태로 바뀐다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/c4ce01a4-1544-4879-86c5-6df3a27c0070)


커밋 여부와 상관없이 InnoDB의 버퍼 풀은 새로운 값으로 업데이트 되며, 기존의 내용은 언두영역으로 복사된다. 

이때 `다른 사용자`가 작업 중인 레코드를 조회하면 어떻게 될까?

```sql
mysql> SELECT * FROM member WHERE m_id=12;
```

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/06caa0f4-6abf-4555-88d4-a9fdeb9efe84)


이는 transaction_isolation 시스템 변수의 격리 수준을 따른다. 

```sql
mysql> SHOW GLOBAL VARIABLES LIKE 'transaction_isolation';
```

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/cbb872ea-503b-4e1e-876d-07c0a6a38501)


`READ_UNCOMMITTED`인 경우, InnoDB 버퍼 풀이 현재 가지고 있는 `변경된 데이터`를 읽는다. 

`READ_COMMITTED 이상의 격리 수준`이라면 아직 커밋 전이므로 InnoDB 버퍼 풀이나 데이터 파일의 내용 대신 `언두 영역의 데이터`를 반환한다. 

이러한 과정을 MVCC라고 표현한다. 레코드의 여러 버전이 유지되고, 필요에 따라 보여지는 데이터가 달라지는 구조다. 

커밋을 하면 영구적인 데이터로 만들고, 롤백을 하면 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 복구하고 언두 영역의 내용은 삭제한다. 커밋이 되더라도 언두 영역의 백업 데이터가 바로 삭제되는 것은 아니다. 언두 영역을 필요로 하는 트랜잭션이 없을 때 삭제된다. 

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

InnoDB 스토리지 엔진은 앞서 본 `MVCC를 이용`해 `잠금을 걸지 않고 읽기` 작업을 수행한다. 덕분에 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기가 가능하다. 

격리 수준이 `READ_UNCOMMITTED`나 `READ_COMMITTED`, `REPEATABLE_READ` 수준인 경우 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/18864288-d6db-4230-9f6f-32e64254269e)


InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.

오랜 시간 활성 상태인 트랜잭션은 일관된 읽기를 위해 언두 로그를 유지해야 하기 때문에 문제가 발생할 수 있다. 따라서 트랜잭션이 시작되었다면 `가능한 한 빨리 커밋/롤백`을 하여 트랜잭션을 완료하는 것이 좋다. 

### 4.2.5 자동 데드락 감지

InnoDB 스토리지 엔진은 `잠금 대기 목록`을 `그래프(Wait-for List) 형태로 관리`하여 잠금이 교착 상태에 빠지지 않았는지 체크한다. 

또한, `데드락 감지 스레드`를 가지고 있어 주기적으로 그래프를 검사해 교착 상태의 트랜잭션을 찾아 그중 하나를 강제 종료한다. 트랜잭션의 강제 종료 선택 기준은 `언두 로그의 양`이다. 언두 로그 레코드가 적은 트랜잭션이 롤백의 대상이 된다. 

InnoDB는 기본적으로 MySQL의 테이블 잠금을 감지하지 못해 데드락을 제대로 인식하지 못할 수 있다. 하지만, `innodb_table_locks` 변수를 활성화하면 InnoDB가 테이블과 레코드 잠금 모두를 감지할 수 있게 되어 데드락 감지가 향상된다. 

일반적인 서비스에서 데드락 감지 스레드의 작업은 부담되지 않는 수준이다. 하지만 동시 처리 스레드가 많아지거나 각 트랜잭션의 잠금 개수가 많아지면 데드락 감지 스레드가 느려진다. 

이를 해결하기 위해 `innodb_deadlock_detect` 시스템 변수를 OFF로 설정하여 데드락 감지 스레드의 작동을 멈출 수 있다. 하지만 중재자가 없어지기 때문에 데드락 상황이 발생해도 무한정 대기만 하게 된다. 

`innodb_lock_wait_timeout` 변수를 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환한다. 

데드락 감지 스레드가 부담되어 innodb_deadlock_detect를 OFF로 설정해서 비활성화하는 경우라면 innodb_lock_wait.timeout을 기본값인 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장한다.

### 4.2.6 자동화된 장애 복구

InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다. 자동 복구가 불가능한 손상이 있다면 자동 복구를 멈추고 서버가 종료된다. 

이때는 `innodb_force_recovery` 시스템 변수를 설정해서 서버를 시작해야 한다. 이 설정값은 서버 시작 시 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 한다. 

- `innodb_force_recovery` 설정 값
    - InnoDB의 로그 파일이 손상된 경우 → 6으로 설정
    - InnoDB 테이블의 데이터 파일이 손상된 경우 → 1로 설정
    - 원인을 모를 경우 → 1~6까지 변경하면서 도전
    - 값이 커질수록 심각한 상황 → 손실 가능성 up, 복구 가능성 down

재시작 후에 InnoDB 테이블이 인식되면 데이터를 백업한 뒤 DB와 테이블을 재생성하는 것이 좋다. 

1~6까지의 상황과 해결 방법은 다음과 같다. 

모두 도전해도 서버가 시작되지 않으면 백업을 이용해 재 구축하는 것 말곤 방법이 없다.

기본값은 0이다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/764806a5-175e-4029-b442-e014758b9af2)

