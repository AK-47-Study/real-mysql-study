### 🤕 MySQL 엔진 아키텍처

- `MySQL` 서버는 `MySQL 엔진`, `스토리지 엔진`으로 구분할 수 있다.
- 스토리지 엔진은 `핸들러 API`를 만족하면 누구든지 `스토리지 엔진`을 `구현`해서 `사용`할 수 있다.
- MySQL 서버는 기본적으로 `InnoDB 스토리지 엔진`, `MyISAM 스토리지 엔진`을 제공한다.

MySQL 서버는 다른 `DBMS`에 비해 `구조`가 `독특`하다.

이로 인해 누리는 혜택도 있지만, 다른 `DBMS`에서 문제되지 않을 것들이 `문제`가 되기도 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/876d770f-617e-4a45-b961-5fc9d3a84d80)

- `MySQL`은 대부분의 프로그래밍 언어로부터 `접근 방법`을 지원한다.
- 대표적으로 `Java` 진영은 `JDBC`를 이용해 `MySQL`에 접근할 수 있다.

### 🤚🏼 MySQL 엔진 & 스토리지 엔진

**MySQL 엔진**

- `MySQL 엔진`은 클라이언트의 `접속 요청` 및 `쿼리 요청`을 처리하는 **커넥션 핸들러**와 **SQL 파서** 및 **전처리기**, 쿼리의 최적화를 돕는 **옵티마이저**로 구성되어 있다.
- 표준 `SQL(ANSI SQL)` 문법으로 작성된 `SQL`은 다른 `DBMS`와 호환이 가능하다.

**스토리지 엔진**

- 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 담당한다.
- MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.

예를 들어, 아래와 같이 `테이블`이 사용할 `스토리지 엔진`을 `지정`하면 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 정의된 `스토리지 엔진`이 `처리`한다.

```sql
mysql> CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

각 `스토리지 엔진`은 성능 향상을 위해 `키 캐시`(MyISAM 스토리지 엔진)나 `InnoDB 버퍼 풀`(InnoDB 스토리지 엔진) `기능`을 `내장`하고 있다.

### 🤓 핸들러 API

- `MySQL` 엔진의 `쿼리 실행기`에서 데이터를 쓰거나 읽을 때는 `스토리지 엔진`에 `요청`을 해야한다.
- 이러한 요청을 `핸들러 요청`이라고 하고, 여기서 사용되는 API가 `핸들러 API`다.
- `InnoDB 스토리지 엔진`도 핸들러 API를 사용해 `MySQL 엔진`과 데이터를 주고받는다.

`핸들러 API`를 통해 얼마나 많은 데이터 작업이 있었는지 확인 하려면 `아래의 명령`으로 확인할 수 있다.

```sql
mysql> SHOW GLOBAL STATUS LIKE 'Handler%';
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/98d79fa0-d149-46bd-85c7-41570eb4d766)

### 🤢 MySQL 스레딩 구조

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9e0e708f-dd63-4240-a83b-02ccfedfbce2)

- `MySQL 서버`는 **프로세스** 기반이 아니라 `스레드 기반`으로 작동한다.
- 작동하는 스레드는 `포그라운드(Foreground)` 스레드와 `백그라운드(Background)` 스레드로 구분할 수 있다.

`MySQL 서버`에서 실행 중인 `스레드`의 목록이 궁금하다면, 아래의 `쿼리`로 확인할 수 있다.

```sql
## 실행 중인 스레드의 목록 -> performance_schema 데이터베이스의 threads 테이블을 통해 확인

mysql> SELECT thread_id, name, type, processlist_user, processlist_host 
FROM performance_schema.threads ORDER BY type, thread_id;
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/aad77550-2f93-49ab-84c6-b6f3048204c5)

현재 `실행중인 스레드`는 **44**개이며, **41**개의 `백그라운드 스레드`와 **3**개의 `포그라운드 스레드`로 구성되어 있다.

`thread/sql/one_connection` 스레드가 실제 사용자의 요청을 처리하는 `포그라운드 스레드`이다.

`백그라운드 스레드`의 개수는 MySQL `서버 설정`에 따라 `가변적`일 수 있다.

`동일한 이름의 스레드`가 `2개` 이상씩 보이는 경우 MySQL 서버의 설정에 의해 `여러 스레드`가 **동일 작업을 병렬로 처리**하는 경우에 나타난다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/199c59ec-d7d8-4aa4-a803-4adcae763fd1)

### 🏀 포그라운드 스레드(클라이언트 스레드)

- `포그라운드 스레드`는 최소한 `MySQL` 서버에 접속된 **클라이언트의 수**만큼 `존재`한다.
- 각 `클라이언트` 사용자가 요청하는 `쿼리 문장`을 처리한다.
- `클라이언트` 사용자가 작업을 마치고 `커넥션`을 `종료`하면 `스레드 캐시`로 되돌아 간다.
- `스레드 캐시`에 일정 개수 이상의 대기 중인 스레드가 있다면, `스레드 캐시`에 넣지 않고 `스레드`를 `종료`한다.

`스레드 캐시`에 유지할 수 있는 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정할 수 있다.

`포그라운드 스레드`는 데이터를 `MySQL`의 **데이터 버퍼**나 **캐시**로부터 가져오고, `버퍼`나 `캐시`에 없는 경우 직접    `디스크`의 데이터나 `인덱스 파일`로부터 데이터를 읽어와서 작업을 처리한다.

`MyISAM` 테이블은 **디스크 쓰기 작업**까지 `포그라운드 스레드`가 처리하고,

`InnoDB` 테이블은 **데이터 버퍼**나 **캐시**까지만 `포그라운드 스레드`가 처리하고, 나머지 **버퍼**로부터 **디스크**까지 기록하는 작업은 `백그라운드 스레드`가 처리한다.

`MyISAM`도 지연된 쓰기는 있지만, 일반적인 방식은 아니다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/4f1da89d-d877-4f41-8cdd-fd7b13b69687)

### 😕 백그라운드 스레드

`InnoDB`는 아래와 같이 여러 가지 작업이 백그라운드로 처리된다.

- `인서트 버퍼(Insert Buffer)`를 **병합**하는 스레드
- **로그**를 **디스크**로 `기록`하는 스레드
- `InnoDB 버퍼 풀`의 데이터를 디스크에 기록하는 스레드
- `데이터`를 버퍼로 읽어 오는 스레드
- `잠금`이나 `데드락`을 모니터링하는 스레드

모두 `중요한 역할`을 수행하고 있지만, 가장 중요한 것은 `로그 스레드`와 `쓰기 스레드`라고 볼 수 있다.

MySQL `5.5` 버전부터 `데이터 쓰기 스레드`와 `데이터 읽기 스레드`의 개수를 `2개` 이상 지정할 수 있다.

`innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 스레드의 개수를 설정한다.

`읽는 작업`은 주로 `클라이언트 스레드`가 처리하기 때문에 많은 스레드가 필요없지만,

`쓰기 스레드`는 아주 많은 작업을 백그라운드로 처리하므로 `내장 디스크`의 경우 **2~4**, 

`DAS` & `SAN`과 같은 스토리지를 사용한다면 **충분히 설정**하는 것이 좋다.

`사용자`의 요청을 처리하는 도중 `데이터 쓰기 작업`은 `지연(버퍼링)`되어 처리 될 수 있다.

하지만 데이터의 `읽기 작업`은 절대 지연될 수 없다.

일반적인 상용 `DBMS`는 쓰기 작업을 `버퍼링`해서 `일괄 처리`하는 기능이 대부분 탑재되어 있다.

`InnoDB` 역시 이러한 방식으로 처리하고 있다.

`MyISAM`은 사용자 스레드가 `쓰기 작업` 까지 함께 처리하도록 `설계` 되어있다.

`MyISAM`에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

### 🥲 메모리 할당 및 사용 구조

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3ba19fb1-5df4-411d-b750-05196953371f)

- `MySQL`에서 사용되는 `메모리 공간`은 **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 구분된다.
- `글로벌 메모리 영역`의 모든 메모리 공간은 MySQL 서버가 시작되면서 `운영체제`가 `할당`한다.

`운영체제`가 메모리를 `할당`하는 방식은 매우 복잡하고, `운영 체제`의 종류에 따라 

요청된 공간을 `100% 할당`해줄수도 있고 그 공간만큼 `예약`해두고 `조금씩 할당`해 줄 수도 있다.

`글로벌 메모리 영역`과 `로컬 메모리 영역`은 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

### 🧔🏼‍♂️ 글로벌 메모리 영역

- `클라이언트 스레드`의 수와 무관하게 `하나의 메모리 공간`만 할당된다.
- 필요에 따라 `2개 이상`의 메모리 공간을 할당받을 수 있지만 `클라이언트 스레드 수`와는 `무관`하다.
- 생성된 글로벌 영역이 `N개`라 하더라도 `모든 스레드`에 의해 `공유`된다.

대표적인 `글로벌 메모리 영역`은 아래와 같다.

- `테이블 캐시`
- InnoDB `버퍼 풀`
- InnoDB `어댑티브 해시 인덱스`
- InnoDB `리두 로그 버퍼`

### 😄 로컬 메모리 영역

- `세션 메모리 영역`이라고도 표현하며 `MySQL` 서버상에 존재하는 `클라이언트 스레드`가 쿼리를 처리하는데    사용하는 `메모리 영역`이다.
- 대표적으로 `커넥션 버퍼`와 `정렬(소트)`버퍼 등이 있다.
- `클라이언트 메모리 영역`이라고 부르기도 한다.

`로컬 메모리`는 각 `클라이언트 스레드`별로 독립적으로 할당되고 절대 `공유`되어 사용되지 않는다.

`로컬 메모리 영역`을 크게 신경 쓰지 않고 설정하는데 최악의 경우 `MySQL 서버`가 `메모리 부족`으로 멈출 수 있다.

`로컬 메모리 공간`은 각 `쿼리`의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 `MySQL`이 메모리 공간을 **할당조차도 하지 않을 수 있다.**

`소트 버퍼`나 `조인 버퍼`와 같은 공간이 특히 그렇다.

`로컬 메모리 공간`은 **커넥션이 열려 있는 동안 계속 할당된 상태**로 남아 있는 `공간`도 있고,

**쿼리를 실행하는 순간에만 할당**했다가 `다시 해제`하는 `공간`도 있다.

대표적인 `로컬 메모리 영역`은 아래와 같다.

- 정렬 버퍼(Sort buffer)
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 😑 플러그인 스토리지 엔진 모델
![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/ce107921-4d35-406a-9f8f-7e51af5c763e)


- `MySQL`의 독특한 구조 중 대표적인 것이 `플러그인 모델`이다.
- `플러그인`해서 사용할 수 있는 것이 `스토리지 엔진`만 존재하는 것은 아니다.

`MySQL`은 기본적으로 `많은 스토리지 엔진`을 가지고 있지만, 모든 사용자의 요구 조건을 만족시킬 수 없다.

따라서 `부가적인 기능`을 더 제공하는 `스토리지 엔진`은 **사용자 또는 다른 회사가 개발해서 사용한다.**

`MySQL`에서 쿼리를 실행한다면, `MySQL 엔진`에서 **거의 대부분의 작업이 처리**된다.

마지막 `데이터 읽기 & 쓰기` 작업만 **스토리지 엔진에 의해 처리**된다.

사용자가 `새로운 용도`의 `스토리지 엔진`을 만든다면, **전체 기능**이 아닌 **일부분의 기능**만 `수행`한다.
![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/46671d26-c616-4e1b-897d-d6298c170107)

데이터 읽기 & 쓰기 작업은 대부분 1건의 레코드 단위로 처리된다.

`MySQL`을 사용하다 보면 `핸들러`라는 단어가 자주 등장한다.

`핸들러`라는 단어는 `MySQL 서버`의 `소스코드`로부터 넘어온 표현이며, `MySQL 엔진`이 **스토리지 엔진**을 조정하기 위해 `핸들러`를 **사용**한다고 이해하면 쉽다.

`MySQL 서버`의 **상태 변수**라는 개념이 나오는데, `Handler_`로 시작하는 변수는 `MySQL 엔진`이

각 `스토리지 엔진`에게 보낸 **명령의 횟수**를 의미하는 `변수`라고 생각하면 된다.

`MySQL`에서 `MyISAM`이나 `InnoDB`와 같이 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행해도

`MySQL`의 **처리 내용은 대부분 동일**하다.

다만 실질적인 `GROUP BY`나 `ORDER BY` 등 복잡한 처리를 **MySQL 엔진의 쿼리 실행기가 처리**한다.

`MySQL서버(mysqld)`에서 지원되는 `스토리지 엔진`이 어떤 것이 있는지 확인하려면

아래의 명령을 실행하면 된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/f2d1702a-33b7-409b-95c8-01c8edb2466f)

조회 된 데이터 중 `Support 컬럼`에 표시될 수 있는 값은 아래와 같다.

- `YES` : MySQL 서버에 해당 스토리이 엔진이 포함되어 있고 사용가능으로 활성화된 상태
- `DEFAULT` : ‘YES’와 동일한 상태이지만 필수 스토리지 엔진이다.
- `NO` : 현재 MySQL 서버에 포함되지 않았음을 의미함
- `DISABLED` : 현재 MySQL 서버에는 포함되어 있지만 파라미터에 의해 비활성화 된 상태임

**MySQL 서버에 포함되지 않은 스토리지 엔진**을 사용하려면 `MySQL 서버`를 `다시 빌드` 해야 한다.

물론, `플러그인 형태`로 빌드된 **스토리지 엔진 라이브러리**를 다운로드해서 끼워 넣기만 하면 `사용`은 `가능`하다.

`플러그인 형태`의 스토리지 엔진은 손쉽게 업그레이드 할 수 있다는 장점이 있다.

`스토리지 엔진`뿐만 아니라 모든 플러그인의 내용은 아래의 명령어로 확인할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/4efe435e-09c6-45fd-9fcf-d2e42eeefc82)

`외부`에서 `플러그인`을 다운로드 받아 사용하는 것이 일반적이지만, 사용자가 **요구사항에 맞게 커스텀**해야 한다면,

`플러그인 API`가 매뉴얼에 공개되어 있으므로 직접 `개발`하거나 `확장`할 수 있다.

### 🌈 컴포넌트

`MySQL 8.0` 버전 부터는 기존의 플러그인 아키텍처를 `대체`하기 위해 `컴포넌트 아키텍처`를 지원한다.

`플러그인`은 아래와 같은 몇 가지 단점이 있어, `컴포넌트`가 단점을 **보완해서 구현**됐다.

- `플러그인`은 오직 **MySQL 서버**와 `인터페이스`할 수 있고, `플러그인`끼리는 통신할 수 없다.
- `플러그인`은 **MySQL 서버**의 변수나 함수를 직접 호출하기 때문에 안전하지 않다(`캡슐화` 안 됨)
- `플러그인`은 **상호 의존 관계**를 설정할 수 없어서 `초기화`가 어렵다.

`플러그인`과 마찬가지로 `컴포넌트`도 설치하면서 새로운 시스템 변수를 설정해야 할 수도 있다.

따라서 `컴포넌트`를 사용하기 전에 관련 `매뉴얼`을 살펴보는 것이 좋다.

### 🫡 쿼리 실행 구조

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/54604e8f-1fed-4ea8-8e4e-b363860ecdbb)

`쿼리`를 **실행하는 관점**에서 `MySQL`의 `구조`는 위의 그림과 같이 표현할 수 있다.

**쿼리 파서**

- `쿼리 파서`는 사용자 요청으로 들어온 쿼리 문을 토큰으로 분리해 `트리 형태`의 `구조`로 만들어낸다.
- `쿼리 문장`의 **기본 문법 오류**는 이 과정에서 발견되고 사용자게에 `오류 메시지`를 `전달`하게 된다.

**전처리기**

- `파서 과정`에서 만들어진 `파서 트리`를 기반으로 `쿼리 문장`에 **구조적인 문제점이 있는지 확인**한다.
- 각 `토큰`을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 **개체를 매핑**한다.
- 해당 객체의 `존재 여부`와 `접근 권한` 등을 `확인`하고, **존재하지 않거나 권한상 사용할 수 없는 개체의 토큰**은 이 단계에서 걸러진다.

**옵티마이저**

- `옵티마이저`란 사용자의 요청으로 들어온 `쿼리 문장`을 저렴한 비용으로 **가장 빠르게 처리할지 결정하는 역할**을 담당한다.
- `옵티마이저`의 역할은 중요하고 **영향 범위 또한 아주 넓다.**

### 😑 실행 엔진

`옵티마이저`가 **두뇌**라면 `실행 엔진`과 `핸들러`는 **손과 발**에 비유할 수 있다.

`옵티마이저`와 `실행 엔진` 그리고 `핸들러`의 관계에서 **GROUP BY**를 처리한다면 어떻게 처리할까?

`옵티마이저`가 **임시 테이블을 사용하기로 결정**했다는 가정하에 만들어진 예제다.

1. `실행 엔진`이 핸들러에게 `임시 테이블`을 만들라고 요청
2. 다시 실행 엔진은 `WHERE 절`에 일치하는 레코드를 읽어오라고 `핸들러`에게 요청
3. 읽어온 레코드들을 1번에서 준비한 `임시 테이블로 저장`하라고 다시 `핸들러`에게 요청
4. 데이터가 준비된 `임시 테이블`에서 필요한 방식으로 데이터를 읽어 오라고 `핸들러`에게 다시 요청
5. 최종적으로 `실행 엔진`은 `결과`를 **사용자나 다른 모듈로 넘김**

`실행 엔진`은 만들어진 계획대로 각 `핸들러`에게 요청해서 받은 결과를 또 다른 `핸들러` 요청의 입력으로 연결하는 

`역할`을 `수행`한다.

### 🤓 핸들러(스토리지 엔진)

- `MySQL` 서버의 `가장 밑단`에서 MySQL `실행 엔진`의 요청에 따라 **데이터를 디스크로 저장하고 읽어 오는 역할을 담당한다.**
- `핸들러`는 결국 **스토리지 엔진을 의미한다.**
- `핸들러`는 `MyISAM 테이블`을 조작하면 **MyISAM 스토리지 엔진**, `InnoDB 테이블`을 조작하면 **InnoDB 스토리지 엔진**이다.

### 😐 쿼리 캐시

- `MySQL 서버`에서 `쿼리 캐시(Query Cache)`는 **빠른 응답을 필요로 하는 응용 프로그램**에서 매우 중요한    역할을 담당했다.
- `쿼리 캐시`란 **SQL의 실행 결과**를 `메모리`에 `캐시`하고, **동일 SQL 쿼리가 실행**하면 `테이블`을 읽지 않고     `즉시`  결과를 반환하여 **성능이 매우 높았다.**

`쿼리 캐시`는 **테이블의 데이터가 변경**되면 `캐시`에 저장된 결과 중에서 `변경된 테이블`과 관련 있는 

**데이터는 모두  삭제**해야 했다.

이로 인해 심각한 `동시 처리 성능 저하`를 유발하고 `많은 버그의 원인`이 되어 왔기에 **8.0 버전부터 제거** 되었다.

`쿼리 캐시` 기능은 `데이터 변경`이 거의 없고 읽기만 하는 서비스에서는 `큰 효율`을 주겠지만,

대부분 실제 큰 도움이 되지 않고 `버그`만 유발하기에 `삭제` 한 것은 좋은 선택이다.

### 🤑 스레드 풀

- 내장 `스레드 풀` 기능은 **MySQL 엔터프라이즈 에디션**만 지원한다.
- **MySQL 커뮤니티 버전**은 `Percona Server`에서 제공하는 `스레드 풀` 기능을 `사용`할 수 있다.

`MySQL 엔터프라이즈` 스레드 풀 기능은 **MySQL 서버 프로그램에 내장**되어 있지만,

`Percona Server` 스레드 풀은 **플러그인 형태로 작동하게 구현**되어 있다.

`스레드 풀`은 내부적으로 **사용자의 요청을 처리하는 스레드 개수**를 줄여서 `동시 처리`되는 `요청`이 많아도,

`CPU`가 **제한된 개수의 스레드 처리에만 집중**할 수 있게 해서 `서버`의 `자원 소모`를 줄이는 것이 `목적`이다.

`스레드 풀`을 설치한다고 해서 `드라마틱`하게 `성능`이 향상되지 않는다.

`스레드 풀`이 `실제 서비스`에서 **눈에 띄는 성능 향상을 보여준 경우는 극히 드물다.**

심지어 `스케줄링 과정`에서 `CPU 시간`을 제대로 확보하지 못한다면 **쿼리 처리가 더 느려질 수도 있다.**

`제한된 수의 스레드`만으로 **CPU가 처리하도록 적절히 유도**하면 `불필요한 컨텍스트 스위치 비용`도 낮추는

장점도 얻을 수 있다.

`Percona Server`의 `스레드 풀`은 기본적으로 **CPU 코어의 개수만큼 스레드 그룹을 생성**한다.

`스레드 그룹`의 개수는 **thread_pool_size 시스템 변수를 변경해서 조정**할 수 있다.

`일반적`으로는 **CPU 코어의 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는 데 좋다.**

`MySQL 서버`가 처리해야 할 요청이 생기면 `스레드 풀`로 처리를 이관하는데, 이미 `스레드 풀`이 처리 중인

작업이 있는 경우 `thread_pool_oversubscribe`에 **설정된 개수만큼 추가로 더 받아들인다.**

이 값이 너무 크면 `스케줄링`해야 할 `스레드`가 많아져서 **스레드 풀이 비효율적으로 작동할 수도 있다.**

`스레드 그룹`의 모든 `스레드`가 일을 처리하고 있다면, `스레드 풀`은 해당 스레드 그룹에 `새로운 작업 스레드`를

추가할 지, **기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부**를 `판단`해야 한다.

`스레드 풀`의 `타이머 스레드`는 **주기적으로 스레드 그룹의 상태를 체크**해서 `thread_pool_stall_limit` 

시스템 변수에 정의된 밀리초만큼 **작업 스레드가 현재 작업을 끝내지 못하면 새로운 스레드를 생성**해서

`스레드 그룹`에 `추가`한다.

전체 `스레드 풀`에 있는 `스레드의 개수`는 **thread_pool_max_threads 값을 넘어설 수 없다.**

모든 `스레드 그룹`의 스레드가 **각자 작업을 처리하고 있는 상태**에서 `새로운 쿼리 요청`이 들어올 경우,

스레드 풀은 `thread_pool_stall_limit` 시간 동안 기다려야 **새로운 요청 처리가 가능하다.**

`응답 시간`에 아주 민감한 서비스라면 `thread_pool_stall_limit` 값을 적절히 낮춰서 설정해야 하는데,

`thread_pool_stall_limit`을 **0에 가까운 값으로 설정하는 것은 권장하지 않는다.**

`thread_pool_stall_limit`을 **0에 가까운 값**으로 설정해야 한다면 `스레드 풀`을 **안쓰는 것이 나을 정도다.**

`Percona Server`의 스레드 풀 플러그인은 `선순위 큐`와 `후순위 큐`를 이용해 

특정 `트랜잭션`이나 `쿼리`를 우선적으로 처리할 수 있는 기능도 제공하고 있다.

`먼저 시작된 트랜잭션` 내에 속한 **SQL을 빨리 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제**되고

`잠금 경합`을 낮춰서 **전체적인 처리 성능을 향상**시킬 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/e521a734-4c79-406e-b2fc-3192dd3368ee)

### 😐 트랜잭션 지원 메타데이터

- `데이터베이스 서버`에서 테이블의 `구조 정보`, `스토어드 프로그램` 등의 정보를 `데이터 딕셔너리` 또는 **메타데이터**라고 한다.
- `MySQL 5.7` 버전까지는 `테이블의 구조`를 **FRM 파일에 저장**하고 일부 `스토어드 프로그램`도 **파일 기반으로 관리했다.**

`파일 기반`의 **메타데이터**는 생성 및 변경 작업이 `트랜잭션`을 **지원하지 않는다는 문제점**이 있다.

`테이블`의 **생성**이나 **변경** 도중 `서버`가 **비정상적으로 종료**되면 `일관되지 않은 데이터`가 남게된다.

`MySQL 8.0` 버전부터는 **테이블**의 `구조 정보`나 **스토어드 프로그램**의 `코드 관련 정보`를 `InnoDB`의 

테이블에 저장하도록 개선하고, `InnoDB` **스토리지 엔진**을 `사용`하도록 했다..

`MySQL 서버`가 작동하는데 `기본적`으로 필요한 `테이블`들을 묶어서 **시스템 테이블**이라고 부르는데,

대표적으로 `사용자의 인증` 또는 `권한`에 관련된 `테이블`들이 있다.

`시스템 테이블`과 `데이터 딕셔너리` 정보를 모두 모아서 **mysql DB**에 저장하고, 이 데이터들은 통째로

`mysql.ibd`라는 파일로 저장된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3645f4ca-f276-46e3-880c-f52d2495f726)

`8.0` 버전부터 서버가 비정상적으로 종료된다고 하더라도 `스키마 변경`이 **완전한 성공 또는 실패**로 `정리`된다.

그렇다면 `MyISAM`이나 `CSV`와 같은 다른 **스토리지 엔진**들은 어떨까?

`MySQL 서버`는 **InnoDB 스토리지 엔진** 이외의 스토리지 엔진을 사용하는 테이블들은 **SDI 파일**을 사용하게 한다.

기존의 `FRM 파일`과 동일한 역할을 하며, `InnoDB 테이블`의 구조도 `SDI 파일`로 `변환`이 가능하다.

`ibd2sdi` 유틸리티를 사용하면 `InnoDB 테이블 스페이스`에서 **스키마 정보를 추출**할 수 있다.

추출한 스키마를 `JSON 파일`로 `덤프`해서 확인할 수도 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/2bf1cef1-82f8-48fe-aa9f-5a3680c16e5f)

### 🙂 InnoDB 스토리지 엔진 아키텍처

- `InnoDB`는 **MySQL**에서 사용할 수 있는 `스토리지 엔진` 중 **거의 유일하게 레코드 기반의 잠금**을 `제공`한다.
- `높은 동시성 처리`가 가능하고 **안정적이며 성능이 뛰어나다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/31c968cf-723c-422c-a79d-b3808c53fa38)

**프라이머리 키에 의한 클러스터링**

- `InnoDB`의 모든 테이블은 기본적으로 `프라이머리 키`를 기준으로 **클러스터링되어 저장된다.**
- 모든 `세컨더리 인덱스`는 레코드의 주소 대신 `프라이머리 키의 값`을 **논리적인 주소로 사용**한다.

`클러스터링 인덱스`의 `레인지 스캔`은 상당히 빨리 처리될 수 있으므로, `쿼리의 실행 계획`에서 `프라이머리 키`는

기본적으로 다른 `보조 인덱스`보다 **비중이 높게 설정**되어 있다.

`오라클 DBMS`의 **IOT(Index organized table)**와 동일한 구조가 `InnoDB`에서는 

**일반적인 테이블의 구조**가 된다.

`MyISAM` 스토리지 엔진은 `클러스터링 키`를 **지원하지 않는다.**

따라서 `MyISAM` 테이블에서는 `프라이머리 키`와 `세컨더리 인덱스`는 **구조적으로 차이가 없다.**

`MyISAM` 테이블의 `프라이머리 키`를 포함한 `모든 인덱스`는 **물리적인 레코드의 주소 값(ROWID)**를 가진다.

**외래 키 지원**

- `외래 키`에 대한 지원은 `InnoDB 스토리지` **엔진 레벨에서 지원하는 기능**이다.
- `MyISAM`이나 `MEMORY` 테이블에서는 사용할 수 없는 기능이다.

`외래 키`를 **데이터베이스 서버 운영**이 불편해서 사용하지 않는 경우가 있는데 왜 그런걸까?

`InnoDB`에서 **외래 키**는 `부모 테이블`과 `자식 테이블` 모두 **해당 컬럼에 인덱스 생성**이 필요하다.

`데이터 변경` 시에는 **부모 테이블**이나 **자식 테이블**에 `데이터`가 있는지 `체크하는 작업`이 필요한데, 이 작업은

`여러 테이블`에 `잠금`을 `전파`할 수 있으므로 `데드락`이 발생할 수 있다.

`수동`으로 `데이터`를 적재하거나 `스키마 변경` 등의 **관리 작업**에도 `실패`할 수 있다.

한 번 `작업`이 꼬이기 시작하면 `외래 키`가 `복잡`하게 얽힌 경우에는 `간단`하게 `해결`하기가 어렵다.

이럴때는 `외래 키` 관계에 대한 `체크 작업`을 멈추게 할 수 있는데 `foreign_key_checks` 시스템 변수의 값을

`OFF`로 `설정`하면 된다.

```sql
mysql> SET foreign_key_checks=OFF;

// 작업 실행

mysql> SET foreign_key_checks=ON;
```

`외래 키` 체크를 해제했다고 해서, **부모 자식 테이블**의 `관계`를 **깨진 상태로 놓아도 된다는 것이 아니다.**

`외래 키 관계`를 가진 **부모 테이블**의 `레코드`를 **삭제**했다면 `자식 테이블`의 **레코드**도 

`삭제`해서 **일관성을 유지**해야 한다.

`일관성`을 전부 맞췄다면, `외래 키 체크 기능`을 **활성화**해야 한다.

`foreign_key_checks`가 비활성화되면 **외래 키 관계**의 `부모 테이블`에 대한 **작업도 무시**되기 때문이다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/63b2be60-d1c4-439c-988d-c2a92c8bba15)

### 😚 MVCC(Multi Version Concurrency Control)

- `레코드 레벨`의 **트랜잭션**을 지원하는 `DBMS`는 **MVCC**를 제공한다.
- `MVCC`의 목적은 **잠금**을 사용하지 않는 `일관된 읽기`를 **제공**하는 것이다.
- `InnoDB`는 이 기능을 **언두 로그(Undo Log)**를 이용해 `구현`하고 있다.

`멀티 버전`이란 **하나의 레코드**에 대해 `여러 개의 버전`이 `동시`에 `관리`되고 있다는 의미다.

격리 수준이 `READ_COMMITED`인 경우 테이블의 **데이터 변경**을 어떻게 처리하는지 아래의 그림으로 

이해해 볼 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3c39c4e2-cffe-41f1-a55c-e5bec94cc010)

위의 `쿼리`를 실행하면 `InnoDB 엔진`은 아래와 같이 처리한다.

- `INSERT` 문 실행시의 그림

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/bee14f44-9f51-40fa-8e69-e240ff75011f)

- `UPDATE` 문 실행시의 그림

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/a19e6d8c-1c01-4e1d-9557-8527dbcb3fa7)

`UPDATE` 문장이 실행되면 `커밋 실행` 여부와 관계없이 **InnoDB 버퍼 풀**은 새로운 값인 ‘경기’로 업데이트 된다.

`디스크`의 데이터 파일에는 `체크포인트`나 `InnoDB`의 **Write 스레드**에 의해 새로운 값으로 

`업데이트` 될 수도 있고 아닐 수도 있다.

그렇다면, 아직 `COMMIT`이나 `ROLLBACK` 되지 않은 상태에서 **사용자가 조회를 시도**하면 어떻게 될까?

`MySQL` 서버의 시스템 변수 `transaction_isolation`에 설정된 `격리 수준`에 따라 다르다.

- `READ_UNCOMMITED`

`InnoDB 버퍼 풀`이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.

데이터의 `커밋 여부`와 상관없이 **변경된 상태의 데이터**를 `반환`하는 것이다.

- `그 이상의 격리 수준`

`READ_UNCOMMITED` 이상의 격리 수준인 `READ_COMMITED`나 `REPEATABLE_READ`,

`SERIALIZABLE`인 경우에는 **언두 영역의 데이터를 반환**한다.

즉 `MVCC`는 하나의 레코드에 대해 `2개 버전`이 유지되고, 필요에 따라 어떤 `데이터`가 보여지는지

**상황에 따라 달라지는 구조**를 가지고 있다.

물론, 예제는 `한 개의 데이터`만 가지고 설명하고 있지만 `예전 버전의 데이터`는 **무한히 많아질 수 있다.**

`COMMIT` 명령이 수행되면, `InnoDB`는 더 이상 변경 작업 없이 현재 상태를 `영구히 반영`한다.

`ROLLBACK` 명령이 수행되는 경우, `언두 영역`에 있는 `백업 데이터`를 **InnoDB 버퍼 풀로 다시 복구**하고,

**언두 영역의 내용을 삭제**한다.

### 🤪 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- 격리 수준이 `SERIALIZABLE`이 아니라면, `INSERT`와 연결되지 않는 **순수한 읽기 작업**은 `잠금 대기` 없이 바로 실행된다.
- `특정 사용자`가 `레코드`를 변경하고 아직 `커밋`을 수행하지 않아도, **변경 트랜잭션**은 다른 사용자의 조회 작업을 방해하지 않는다.
- 이를 `잠금 없는 일관된 읽기` 라고 `표현`한다.
- `InnoDB`에서는 변경되기 전의 데이터를 읽기 위해 `언두 로그`를 사용한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/ca316d5e-683c-4e07-8cd5-82a1a2ee4082)

`오랜 시간` 동안 **활성 상태인 트랜잭션**으로 인해 `MySQL` 서버가 느려지거나 `문제`가 `발생`하는 경우가 있다.

따라서 `트랜잭션`이 시작되었다면 가능하면 `롤백`이나 `커밋`을 빨리해서 `트랜잭션`을 끝내야 한다.

### 😏 자동 데드락 감지

- `InnoDB` 스토리지 엔진은 내부적으로 잠금이 `교착 상태`에 빠지지 않았는지 `체크`한다.
- `잠금 대기 목록`은 **그래프(Wait-for List) 형태로 관리**한다.
- `InnoDB` 스토리지 엔진은 **데드락 감지 스레드**를 활용해 `데드락`을 **주기적으로 감지**한다.

`데드락 감지 스레드`는 **잠금 대기 그래프**를 주기적으로 검사하여 `교착 상태`에 빠진 `트랜잭션`들 중 하나를

`강제 종료` 시킨다.

`강제 종료`시킬 `트랜잭션`을 선정하는 기준은, `트랜잭션`이 현재 보유한 `언두 로그 양`으로 판단하며

`언두 로그`가 적은 `트랜잭션`이 종료된다.

`InnoDB` 스토리지 엔진은 상위 레이어인 `MySQL 엔진`에서 관리되는 `테이블 잠금`을 볼 수 없어서

`데드락 감지`가 불확실할 수 있는데, `innodb_table_locks` 시스템 변수를 활성화 하면 `문제`가 `해결`된다.

`InnoDB` 스토리지 엔진 내부의 `레코드 잠금`과 `테이블 레벨`의 `잠금`까지 감지할 수 있게 된다.

물론 `자동 데드락 감지` 기능에도 주의해야 할 점도 있다.

`동시 처리 스레드`가 매우 많아지거나 각 `트랜잭션`이 가진 **잠금의 개수가 많아지는 경우**에는 

`데드락 감지 스레드`가 느려진다.

`잠금 목록`을 검사해야 하기 때문에 `잠금 상태`가 변경되지 않도록 `잠금 목록`이 저장된 리스트에 `새로운 잠금`을

걸고, `데드락 스레드`를 찾기 때문이다.

`데드락 감지 스레드`가 느려지면 **서비스 쿼리**를 처리 중인 `스레드`는 **작업을 진행하지 못하고 대기**하면서 서비스에

`악영향`을 미치게 된다.

`MySQL 서버`는 이 문제를 해결하기 위해서 `innodb_deadlock_detect` 시스템 변수를 제공한다.

이 시스템 변수를 `OFF`로 설정하면 `데드락 감지 스레드`는 더 이상 작동하지 않는다.

이로 인해 `InnoDB` 스토리지 엔진 내부에서 **2개 이상의 트랜잭션**이 

**상대방이 가진 잠금을 요구하는 상황**이 발생해도 `무한정 대기`하는 상황이 오게 된다.

따라서 이런 문제를 방지하려면 `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 된다.

`변수`를 `활성화`하면 **일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환**하게 된다.

`데드락 감지 스레드`가 부담되어 `OFF` 하는 경우, `innodb_lock_wait_timeout`을 기본값인 `50초`보다

훨씬 `낮은 시간`으로 `변경`해서 `사용`하는 것이 좋다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/fbbb6ff7-7875-4226-a800-71306162cf84)

### 😏 자동화된 장애 복구

- `InnoDB`에는 손실이나 장애로부터 `데이터`를 `보호`하기 위한 **여러 가지 메커니즘이 탑재**되어 있다.
- `MySQL 서버`가 시작될 때 **완료되지 못한 일련의 복구 작업이 자동으로 진행**된다.

`InnoDB` 스토리지 엔진은 견고하기 때문에 `데이터 파일`이 `손상`되거나 MySQL 서버가 시작되지 못하는

경우는 **거의 발생하지 않는다.**

`MySQL 서버`와 무관하게 `디스크`나 `서버 하드웨어 이슈`로 InnoDB 스토리지 엔진이 자동으로 복구하지 못하는

경우가 발생할 수 있는데, **이 문제는 복구하기가 쉽지 않다.**

`MySQL 서버`가 시작될 때 항상 `InnoDB 데이터 파일`은 **자동 복구**를 수행하는데, 이 단계에서 자동 복구가 안 될

정도의 손상이 있다면 `자동 복구`를 멈추고 **MySQL 서버가 종료된다.**

이런 상황이 발생하면, `MySQL 서버`의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 

서버를 시작해야 한다.

이 설정 값은 `InnoDB` 스토리지 엔진이 `데이터 파일`이나 

`로그 파일`의 **손상 여부 검사 과정을 선별적으로 진행**할 수 있도록 도와준다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/a92ee32b-2085-4b2c-874f-f2b7f02f4113)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/0b5ba761-19e9-4618-86f7-20418b5e67bf)

`innodb_force_recovery`의 값이 커질수록 심각한 상황이고, 데이터 손실 가능성이 커진다.

`MySQL 서버`가 기동되고 `InnoDB 테이블`이 인식된다면 `mysqldump`를 이용해 **데이터를 가능한 만큼 백업**하고

서버의 `DB`와 `테이블`을 **다시 생성하는 것이 좋다.**

`InnoDB`의 복구를 위해 `innodb_force_recovery` 옵션에 설정 가능한 값은 `1~6`까지 있다.

이 값이 `0`이 아닌 복구 모드에서는 `SELECT` 이외의 **쿼리는 모두 수행할 수 없다.**

각 `숫자 값`으로 복구되는 `장애 상황`과 `해결 방법`은 아래와 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9cc22103-3215-4b8c-8922-25b593cea0e2)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/cb643a7f-96e5-4b83-9695-f65f54c069cc)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/04ddd179-9146-4932-a2b7-8648d1811f86)

`1~6` 까지의 값을 전부 셋팅하고 시도해도 `MySQL 서버`가 **시작되지 않는 최악의 경우가 발생**한다면,

`백업`을 이용해 **다시 서버를 구축하는 방법**밖에 없다.

`마지막 백업`으로 **데이터베이스를 새로 구축**하고, `바이너리 로그`를 사용해 **최대한 장애 시점까지의 데이터를**

**복구**할 수 있을 것이다.

마지막 `풀 백업 시점`부터 `장애 시점`까지의 **바이너리 로그**가 있다면 `InnoDB` 복구를 이용하는 것보다 **풀 백업**과

`바이너리 로그`로 복구하는 편이 `데이터 손실`이 더 적을 수 있다.

`백업`은 있지만 복제의 `바이너리 로그`가 없거나 손실됐다면 마지막 `백업 시점`까지 복구가 가능하다.

### 😉 InnoDB 버퍼 풀

- `InnoDB` 스토리지 엔진에서 **가장 핵심적인 부분**이다.
- `디스크`의 **데이터 파일**이나 **인덱스 정보**를 `메모리에 캐시`해 두는 공간이다.
- `데이터`를 **변경하는 쿼리**는 `데이터 파일`의 이곳 저곳에 위치한 레코드를 변경한다.
- `버퍼 풀`이 변경된 데이터를 모아서 처리하면 **랜덤한 디스크 작업의 횟수를 줄일 수 있다.**

### 🙋🏼‍♂️ 버퍼 풀의 크기 설정

- `버퍼 풀`의 `크기`를 설정하는 일은 **단순하게 설정해서 되는 값이 아니다.**
- `운영체제`와 `클라이언트 스레드`가 사용할 **메모리도 충분히 고려**해서 `설정`해야 한다.
- `MySQL 서버` 내에서 `메모리`를 필요로 하는 부분은 크게 없겠지만 `레코드 버퍼`가 **상당한 메모리를 사용하는 경우도 있다.**
- `MySQL 서버`가 사용하는 `레코드 버퍼` 공간은 별도로 설정할 수 없다.
- `전체 커넥션 개수`와 각 `커넥션`에서 읽고 쓰는 **테이블의 개수에 따라서 결정**된다.

`레코드 버퍼 공간`은 **동적으로 해제**되기도 하기 때문에, 정확히 필요한 `메모리 공간`을 `계산`할 수 없다.

`MySQL 5.7` 버전부터 `InnoDB 버퍼 풀`의 크기를 **동적으로 조절할 수 있게 개선**되었다.

따라서 `InnoDB 버퍼 풀`의 크기를 적절히 `작은 값`으로 설정해서 **상황을 봐 가면서 증가**시키는 방법이 가장 최선의 선택이다.

`MySQL 서버`를 이미 사용하고 있는 경우라면 `서버`의 **메모리 설정을 기준으로 버퍼 풀의 크기를 조정**하면 되고,

`MySQL 서버`를 처음으로 준비하고 있는 상황이라면 아래의 방법을 따라서 해보면 좋다.

- `운영체제`의 전체 메모리 공간이 `8GB 미만`이라면 `50%` 정도만 **InnoDB 버퍼 풀**로 설정
- 전체 메모리 공간이 그 이상이라면 `전체 메모리`의 `50%`에서 시작해서 **조금씩 올려본다.**
- 전체 메모리 공간이 `50GB` 이상일 경우 **15GB ~ 30GB** 정도만 남기고 `InnoDB 버퍼 풀로 할당`한다.

`InnoDB` 버퍼 풀은 `innodb_buffer_size` 시스템 변수로 **크기를 설정**할 수 있다.

`동적`으로 `버퍼 풀`의 **크기를 확장하는 것도 가능**하지만, `버퍼 풀`의 `크기 변경`은 **크리티컬한 변경**에 해당해서

MySQL 서버가 `한가한 시점`을 **골라서 진행하는 것이 좋다.**

`InnoDB` 버퍼 풀을 `더 크게 변경하는 작업`은 **시스템 영향도가 크지 않은 편이다.**

반대로 `버퍼 풀의 크기를 줄이는 작업`은 **서비스 영향도가 매우 높기 때문에 가능하면 하지 않는 것이 좋다.**

`버퍼 풀`은 내부적으로 **128MB 청크 단위**로 쪼개어 관리되는데, 

즉, `버퍼 풀`의 크기를 늘리거나 줄일때는 **128MB 단위로 처리**된다.

`InnoDB` 버퍼 풀은 전통적으로 `버퍼 풀 전체`를 관리하는 **잠금(세마포어)**으로 인해 `내부 잠금 경합`을

많이 유발해왔다.

이런 `경합`을 줄이기 위해서 `버퍼 풀`은 **여러 개로 쪼개어 관리할 수 있게 개선**되었고,

`버퍼 풀`이 여러 개의 작은 `버퍼 풀`로 쪼개지면서 **개별 버퍼 풀 전체를 관리하는 잠금 경합도 분산**되었다.

`innodb_buffer_pool_instances` 시스템 변수를 이용해 `버퍼 풀`을 여러 개로 분리해서 관리할 수 있다.

각 `버퍼 풀`은 버퍼 **풀 인스턴스**라고 표현하며, `기본 인스턴스의 개수`는 `8개`다.

전체 `버퍼 풀`을 위한 메모리 크기가 `1GB 미만`이면 **버퍼 풀 인스턴스는 1개만 생성**되고,

`버퍼 풀`로 할당할 수 있는 메모리 공간이 `40GB 이하` 수준이라면 **기본 값인 8이 유지**된다.

메모리가 크다면 `버퍼 풀 인스턴스` 당 `5GB` 정도의 공간을 잡고 **인스턴스 개수를 설정**하는 것이 좋다.

### 😾 버퍼 풀의 구조

- `InnoDB` 스토리지 엔진은 `버퍼 풀`이 사용하는 `메모리 공간`을 **페이지 크기의 조각으로 쪼개어 관리**한다.
- `innodb_page_size` 시스템 변수에 설정된 값 만큼 쪼개진 공간은 `InnoDB` 스토리지 엔진이 데이터를 필요로 할 때 **해당 데이터 페이지를 읽어서 각 조각에 저장**한다.

`버퍼 풀`의 페이지 크기 조각을 관리하기 위해 `InnoDB` 스토리지 엔진은 **3개의 자료 구조를 관리**한다.

- LRU(Least Recently Used) List
- Flush List
- Free List

**LRU List**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3fc14392-d248-4c49-8f8f-095119a24f96)

- `LRU List`는 LRU와 `MRU(Most Recently Used) List`가 **결합된 형태**라고 볼 수 있다.
- `Old 서브리스트`는 LRU 영역, `New 서브리스트` 영역은 MRU 영역으로 이해하면 쉽다.

`LRU 리스트`를 관리하는 목적은 `디스크`로부터 한 번 읽어온 페이지를 오랫동안 `InnoDB` 버퍼 풀의

`메모리`에 유지해서 **디스크 IO를 최소화**하는 것이다.

`InnoDB` 스토리지 엔진에서 데이터를 찾는 과정은 아래와 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/68e2b43a-11b8-4307-bb9c-0d55d20b55c2)

처음 한 번 읽힌 `데이터 페이지`가 이후 자주 사용된다면, 그 데이터 페이지는 `InnoDB` 버퍼 풀의 `MRU 영역`에서

오래 살아남게 되고, 그 `반대의 경우`에는 `LRU` 끝에서 밀려나 **InnoDB 버퍼 풀에서 제거**된다.

**Flush List**

- `디스크`로 동기화되지 않은 데이터를 가진 `데이터페이지`의 **변경 시점 기준의 페이지 목록을 관리**한다.
- `디스크`에서 **읽은 상태 그대로 전혀 변경이 없는 경우** `Flush List`에 관리되지 않는다.
- **한 번이라도 변경이 가해진 데이터 페이지**는 `Flush List`에 관리되며, `특정 시점`이 지나면 **디스크에 기록되어야 한다.**

`InnoDB`는 데이터가 변경되면 `변경 내용`을 `리두 로그`에 기록하고 

`버퍼 풀`의 **데이터 페이지에도 변경을 반영**한다. `리두 로그`의 각 `엔트리`는 **특정 데이터 페이지와 연결**된다.

`리두 로그`가 **디스크로 기록**되었다고 해서 `데이터 페이지`가 **디스크로 기록되었다는 것을 항상 보장하지 않는다.**

`InnoDB 스토리지 엔진`은 `체크포인트`를 발생시켜, 디스크의 `리두 로그`와 **데이터 페이지의** 

**상태를 동기화**하게 한다.

`체크포인트`는 MySQL 서버가 시작될 때 `InnoDB 스토리지 엔진`이 `리두 로그`의 어느 부분부터

복구를 실행해야 할지 **판단하는 기준점을 만드는 역할**을 한다.

**Free List**

- `InnoDB` 버퍼 풀에서 **실제 사용자 데이터로 채워지지 않은 빈 페이지**들의 `목록`이다.

### 🤫 버퍼 풀과 리두 로그

- `InnoDB`의 버퍼 풀과 `리두 로그`는 **매우 밀접한 관계**를 맺고 있다.
- `InnoDB`의 버퍼 풀은 **서버의 메모리가 허용하는 만큼 크게 설정**하면 할수록 `쿼리의 성능`이 **빨라진다.**

물론 InnoDB의 `버퍼 풀`을 아무리 크게 설정해도 **별다른 도움이 되지 않는 경우**가 있다.

이미 `디스크`의 `모든 데이터 파일`이 **버퍼 풀에 적재**될 정도로 **버퍼 풀 공간이 큰 경우**에는 더 이상 성능에 도움이 

되지는 않을 것이다.

이 경우가 아니라면 대부분 `디스크`의 데이터가 **버퍼 풀 메모리로 적재될 공간이 마련**되면 `성능`이 좋아진다.

InnoDB `버퍼 풀`은 `데이터베이스 서버` 성능 향상을 위한 **캐시와 쓰기 버퍼링 용도로 사용**된다.

`버퍼 풀`의 메모리 공간을 늘리는 것은 `데이터 캐시 기능`만 `향상`시킨다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/e866880a-2ada-4987-b824-33571f523de4)

InnoDB의 `버퍼 풀`은 디스크에서 **읽은 상태로 변경되지 않은** `클린 페이지`와, **데이터 변경 쿼리로**

**변경된 데이터**를 가진 `더티 페이지`를 가지고 있다.

`더티 페이지`는 **디스크와 메모리(버퍼 풀)의 데이터 상태가 다르기 때문에** 언젠가는 `디스크`에

`기록`되어야 한다.

`더티 페이지`가 `버퍼 풀`에 **무한정 머무르는 것**이 아니기 때문에 `더티 페이지`에 할당할 수 있는

**공간을 결정해야 하는 문제**가 생긴다.

`InnoDB` 스토리지 엔진에서 `리두 로그`는 **1개 이상의 고정 크기 파일을 연결해서 사용**한다.

`데이터 변경`이 계속 발생하면 `리두 로그 파일`에 기록되었던 `로그 엔트리`는 **새로운 로그 엔트리로**

**덮어 쓰인다는 이야기다.**

InnoDB `스토리지 엔진`은 `전체 리두 로그 파일`에서 **재사용 가능한 공간**과 **당장 재사용 불가능한 공간**을

`구분`해서 `관리`해야 한다.

위의 그림에서 **화살표를 가진 엔트리**들을 `활성 리두 공간`이라고 한다.

`활성 리두 공간`이란 재사용 불가능한 공간을 의미한다.

`리두 로그 파일`의 공간은 **계속 순환되어 재사용**되지만 매번 기록될 때마다 `로그 포지션`은 계속 증가한다.

이를 `LSN(Log Sequence Number)`이라고 부른다.

`리두 로그`와 `버퍼 풀`의 **더티 페이지를 디스크로 동기화하는 작업**을 InnoDB 스토리지 엔진이 수행하는데,

여기서 발생한 `체크포인트` 중 가장 최근 `체크포인트 지점`의 LSN이 **활성 리두 공간**의 시작점이 된다.

`활성 리두 공간`의 마지막은 계속해서 증가하므로, `체크포인트`와 무관하다.

가장 최근 체크포인트의 LSN과 마지막 `리두 로그 엔트리`의 `LSN`의 차이를 체크포인트 에이지라고 부른다.

InnoDB 버퍼 풀의 `더티 페이지`는 특정 **리두 로그 엔트리**와 `관계`를 가진다.

체크 포인트가 발생하면 `체크 포인트` LSN보다 작은 **리두 로그 엔트리**와 관련된 더티 페이지는 

**모두 디스크와 동기화** 되어야 한다.

그렇다면 `리두 로그 공간`이 무조건 큰 게 좋을까?

버퍼 풀에 `더티 페이지`의 `비율`이 너무 높은 상태에서 갑자기 **버퍼 풀이 필요해지는 상황**이 오면,

InnoDB `스토리지 엔진`은 매우 많은 `더티 페이지`를 한 번에 기록해야 하는 상황이 온다.

`리두 로그 파일`의 크기를 적절히 선택하는 것이 중요하다.

물론 처음 부터 적정 `리두 로그 파일`의 크기를 결정하는 것은 생각보다 어렵기 때문에 필요할때마다

**조금씩 늘려가면서 최적값을 선택하는 것이 좋다.**

### 🤔 버퍼 풀 플러시(Buffer Pool Flush)

- MySQL 5.7 ~ 8.0 업데이트를 거쳐오면서 `더티 페이지 플러시 기능`이 개선되었다.
- 대부분의 서비스에서 `더티 페이지`를 **디스크 동기화하는 부분**에서 예전과 같은 `디스크 쓰기 폭증 현상`이 발생하지 않는다.

InnoDB `스토리지 엔진`은 버퍼 풀에서 아직 디스크로 기록되지 않은 `더티 페이지`들을 `성능`상의 `악영향` 없이

**디스크에 동기화**하기 위해 `2개`의 플러시 기능을 `백그라운드`로 `실행`한다.

### 🤢 플러시 리스트 플러시

- InnoDB `스토리지 엔진`은 `리두 로그 공간`의 재활용을 위해 주기적으로 오래된 `리두 로그 엔트리`가 사용하는 공간을 비워야 한다.
- 오래된 `리두 로그 공간`이 지워지려면 반드시 **InnoDB 버퍼풀의 더티 페이지가 먼저 디스크로 동기화** 되어야 한다.

InnoDB `스토리지 엔진`은 주기적으로 `Flush_list` 플러시 함수를 `호출`해서 

`플러시 리스트`에서 **오래전에 변경된 데이터 페이지를 순서대로 디스크에 동기화**한다.

언제부터 얼마나 많은 `더티 페이지`를 한 번에 `디스크`로 `기록`하느냐에 따라 **사용자의 쿼리 처리가 악영향**을 받지

않으면서 **부드럽게 처리**된다.

InnoDB `스토리지 엔진`은 이를 위해 아래와 같은 `시스템 변수`들을 제공한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/5c35e9ac-ac0f-471e-a37c-eb56ae5b089e)

InnoDB `스토리지 엔진`에서 `더티 페이지`를 **디스크로 동기화하는 스레드**를 `클리너 스레드`라고 한다.

`innodb_page_cleaners` 변수는 **클리너 스레드의 개수를 조정**할 수 있게 해준다.

`innodb_page_cleaners` 설정값이 **버퍼 풀 인스턴스 개수**보다 많다면,

`innodb_buffer_pool_instances` 값으로 **자동으로 변경**한다.

즉, 하나의 `클리너 스레드`가 하나의 `버퍼 풀 인스턴스`를 처리하도록 맞춰주는 것이다.

InnoDB `스토리지 엔진`은 **전체 버퍼 풀이 가진 페이지의 90%**까지 `더티 페이지`를 가질 수 있다.

`innodb_max_dirty_pages_pct` 변수를 이용해 비율은 조절할 수 있다.

더티 페이지를 많이 가지고 있을수록 `디스크 쓰기 작업`의 효율이 극대화되기 때문에,

`innodb_max_dirty_pages_pct` 설정은 **기본값을 유지**하는 것이 좋다.

InnoDB `버퍼 풀`에 `더티 페이지`가 **많으면 많을수록 디스크 쓰기 폭발 현상이 발생**할 수 있다.

그렇다면 이 문제를 어떻게 해결하고 있을까?

`innodb_max_dirty_pages_pct_lwm` 변수로 일정 수준 이상의 `더티 페이지`가 발생하면,

조금씩 **더티 페이지를 디스크로 기록**하게 하고 있다.

`더티 페이지`의 비율이 얼마 되지 않은 상태에서 `디스크 쓰기`가 **많이 발생**하고,

`더티 페이지`의 **비율이 너무 낮은 상태로 유지되는 경우**, 이 값을 `조금 더 높은 값`으로 변경하면

**디스크 쓰기 횟수를 줄이는 효과**를 얻을 수 있다.

`innodb_io_capacity`와 `innodb_io_capacity_max` 변수는 **어느 정도의 디스크 읽고 쓰기가**

**가능한지를 설정하는 값**이다.

디스크 읽고 쓰기란 InnoDB `스토리지 엔진`의 `백그라운드 스레드`가 수행하는 디스크 작업을

의미하는데, 대부분 **버퍼 풀의 더티 페이지 쓰기가 해당**한다.

InnoDB `스토리지 엔진`은 사용자의 쿼리를 처리하기 위해 `디스크 읽기`도 해야하기 때문에,

현재 디스크가 초당 `1000 IOPS`를 처리한다고 해서 **그 값을 그대로 시스템 변수에 설정하면**

**안된다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/2ce57d41-502b-46bc-9d49-47be5f11ec7d)

**어댑티브 플러시(Adaptive flush)**

- InnoDB `스토리지 엔진`은 `어댑티브 플러시` 기능을 제공한다.
- 어댑티브 플러시 기능은 `innodb_adaptive_flushing` 변수로 켜고 끌 수 있다.
- `어댑티브 플러시` 기능이 활성화되면 **기존에 참고하던 시스템 변수나 버퍼 풀의 더티 페이지 비율에 의존**하지 않고 `새로운 알고리즘`을 사용한다.

어댑티브 플러시 알고리즘은 `리두 로그`의 **증가 속도를 분석**해서,

적절한 수준의 `더티 페이지`가 **버퍼 풀에 유지 될 수 있도록 디스크 쓰기를 실행**한다.

`innodb_adaptive_flushing_lwm` 변수의 기본 값은 `10%`인데,

전체 `리두 로그 공간`에서 **활성 리두 공간이 10% 미만이면 어댑티브 플러시가 작동하지 않는다.**

`innodb_flush_neighbors` 시스템 변수는 **더티 페이지를 디스크에 기록**할 때 디스크에서 근접한 

페이지 중에서 `더티 페이지`가 있다면 **묶어서 디스크로 기록하게 해줄지 여부를 결정**한다.

`데이터 저장`을 `하드디스크`로 하고 있다면 **1 또는 2로 설정해서 활성화**하는 것이 좋고,

`SSD`를 사용한다면 **읽고 쓰기 비용이 낮아졌기 때문에 비활성 모드로 유지**하는 것이 좋다.

### 😲 LRU 리스트 플러시

- `LRU 리스트`에서 **사용 빈도가 낮은 데이터 페이지들을 제거**하기 위해 `LRU_list 플러시 함수`를 사용한다.
- `사용 빈도`가 낮은 `데이터 페이지`를 제거해, **새로운 페이지를 읽어올 공간을 만들기 위해서다.**
- LRU 리스트의 끝부분부터 시작해, `innodb_lru_scan_depth`의 값에 **설정된 개수만큼 페이지를 스캔**한다.
- `더티 페이지`는 **디스크에 동기화**하고, `클린 페이지`는 **즉시 Free List로 페이지로 옮긴다.**

### 😤 버퍼 풀 상태 백업 및 복구

- InnoDB 서버의 `버퍼 풀`은 `쿼리의 성능`과 밀접한 연관이 있다.
- 버퍼 풀에 **쿼리들이 사용할 데이터가 적재되어 있는 상황**에서는 `몇십 배의 쿼리 속도`를 보이게 된다.

**MySQL 5.6** 버전부터 `버퍼 풀 덤프 및 적재 기능`이 도입되었다.

서버 점검이나 기타 작업을 위해 `서버 재시작`이 필요한 경우, **버퍼 풀의 상태를 백업**할 수 있게 되었다.

두 가지 `시스템 변수`를 활용해 **버퍼 풀의 상태를 백업**하고, 서버가 다시 시작되면

**백업된 버퍼 풀의 상태를 다시 복구**할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/fab134a5-9001-47f9-a706-e86ed747d80f)

InnoDB `버퍼 풀`의 백업은 데이터 디렉터리에 `ib_buffer_pool` 이라는 이름의 파일로 생성된다.

실제 파일의 크기는 `몇십 MB` 이하로, 스토리지 엔진이 `LRU 리스트`에서 적재된 **데이터 페이지의 메타 정보**만

가져와서 저장하기 때문에 `버퍼 풀`의 백업은 **매우 빨리 완료**된다.

물론, `백업`된 버퍼 풀의 내용을 **버퍼 풀로 복구하는 과정**은 버퍼 풀의 사이즈에 따라 상이하다.

따라서 어느 정도 `복구`가 `수행`됬는지 **확인할 수 있는 상태값을 제공**한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/efe6df41-c926-4684-9aba-a290378059eb)

만약 `버퍼 풀 적재 작업`에 너무 오랜 시간이 걸려서 멈춰야 한다면, **시스템 변수를 조작해 멈출 수 있다.**

버퍼 풀 복구가 실행 중인 상태에서 `서비스`를 `재개`하는 것은 **좋지 않은 선택일 수 있기 때문이다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/35b2533e-8ebc-459e-8557-8a5eb04f15e3)

수동으로 `버퍼 풀`의 **백업과 복구**를 수행하면 `실수할 수 있는 위험`이 있다.

따라서 `MySQL 서버`의 `설정 파일`에 **시스템 변수의 값을 셋팅해 자동화**하는 것이 좋다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d8389355-7d75-42ab-b9cc-284ecac0f337)

### 😌 버퍼 풀의 적재 내용 확인

- `MySQL 8.0` 버전부터 `information_schema` 데이터베이스에 `innodb_cached_indexs` 테이블이 추가되었다.
- 이 테이블을 이용하면 `테이블`의 인덱스별로 데이터 페이지가 `InnoDB 버퍼 풀`에 얼마나 적재됬는지 알 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/da1aed16-9757-4570-9e76-e2a73d098b4d)

위의 `쿼리`를 조금 응용하면, `테이블 전체(인덱스 포함)` 페이지 중에서 대략 어느 정도 비율이 `InnoDB 버퍼 풀`에

**적재되어 있는지 확인**해볼 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/e15ecfaa-6c9e-41bc-80d0-6b9716e9e26a)

`MySQL 서버`는 개별 인덱스별로 `전체 페이지 개수`가 몇 개인지는 사용자에게 알려주지 않는다.

`information_schema` 테이블을 이용해도 `테이블`의 인덱스별로 페이지가 **InnoDB 버퍼 풀에 적재된 비율**은

확인할 방법이 없다.

### 🙃 Double Write Buffer

- InnoDB `스토리지 엔진`의 리두 로그는 **리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록**한다.
- 이로인해 `더티 페이지`를 디스크 파일로 `플러시`할 때 **일부만 기록되는 문제가 발생**할 수 있다.
- `더티 페이지`가 **일부만 기록되는 문제**로 인해 그 `페이지의 내용`은 복구할 수 없을 수 있다.

이 문제를 해결하기 위해서 InnoDB 스토리지 엔진에서는 `Double-Write 기법`을 이용한다.

예를 들어, ‘A’ ~ ‘E’ 까지의 `더티 페이지`를 **디스크로 플러시**한다고 생각해보면

InnoDB `스토리지 엔진`은 실제 `데이터 파일`에 **변경 내용을 기록하기 전**에 ‘A’ ~ ‘E’ 까지의 더티 페이지를

묶어서, 우선 **한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼**에 기록한다.

InnoDB 스토리지 엔진은 각 `더티페이지`를 파일의 적당한 위치에 **하나씩 랜덤으로 쓰기**를 `실행`한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9206f912-ac9e-4973-a2d3-53613022a3f9)

`DoubleWrite` 버퍼의 내용은 **실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용**된다.

InnoDB 스토리지 엔진은 `재시작`될 때 항상 `DoubleWrite` 버퍼의 내용과 데이터 파일의 페이지들을 모두

비교하여, **다른 내용을 담고 있는 페이지**가 있다면 `DoubleWrite` 버퍼의 내용을 **데이터 파일의 페이지로**

**복사한다.**

`DoubleWrite` 기능의 사용여부는 `innodb_doublewrite` **시스템 변수로 제어**할 수 있다.

`SSD`처럼 **랜덤 IO나 순차 IO의 비용이 비슷한 저장 시스템**에서는 `순차 디스크 쓰기`의 `비용`이 `부담`스럽다.

`데이터의 무결성`이 매우 중요한 서비스라면 `DoubleWrite` 기능을 활성화하고,

그것이 아니라면 `비활성화` 하는 것이 좋다.

`데이터베이스` 서버의 성능을 위해서 `innodb_flush_log_at_trx_commit` 변수의 값이 1이 아니라면

**DoubleWrite도 비활성화 하는 것이 좋다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c17fa92b-3906-4bb5-b5a0-d8f697ab30b6)

### 🙂 언두 로그

- InnoDB 스토리지 엔진은 `트랜잭션`과 `격리 수준`을 보장하기 위해 `DML`로 변경되기 이전 버전의 데이터를 별도로 백업한다.
- **백업된 데이터**를 `언두 로그(Undo Log)`라고 부른다.

언두 로그를 사용해서 `트랜잭션`과 `격리 수준`을 어떻게 보장할까?

- `트랜잭션 보장`

트랜잭션이 롤백되면 `언두 로그`에 백업해 둔 **이전 버전의 데이터를 이용해 복구**한다.

- `격리 수준 보장`

**특정 커넥션**에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 `트랜잭션 격리 수준`에 맞게

변경 중인 레코드를 읽지 않고 **언두 로그에 백업해 둔 데이터를 읽어서 반환**한다.

`언두 로그`는 InnoDB 스토리지 엔진에서 매우 중요한 역할을 담당하지만, `관리 비용`도 **많이 필요하다.**

### 🤓 언두 로그 모니터링

- `언두 영역`은 **INSERT, UPDATE, DELETE**와 같은 문장으로 `데이터`를 `변경`했을 때 **이전 데이터를 보관**한다.

```sql
mysql> UPDATE member SET name='홍길동' WHERE member_id=1;
```

위와 같은 업데이트 문장을 실행하면 어떤 일이 일어날까?

`트랜잭션`을 `커밋`하지 않아도 실제 데이터 파일(데이터/인덱스 버퍼) 내용은 **‘홍길동’으로 변경**된다.

변경되기 전의 `데이터`가 `‘조약돌’` 이라면 **언두 영역에는 ‘조약돌’이 백업**되어 있다.

사용자가 `커밋`하면 **현재 상태가 유지**되고 `롤백`하면 **언두 영역의 데이터가 백업되어 데이터 파일로 복구**한다.

**언두 로그의 문제점**

- `MySQL 5.5` 이전 버전에서는 **한 번 증가한 언두 로그 공간은 줄어들지 않았다.**
- `대용량 데이터`를 저장한 테이블의 데이터를 삭제 하면, `테이블`의 용량만큼 `언두 로그`에 값을 저장한다.
- `트랜잭션`이 오랜 시간 동안 실행될 때도 **언두 로그의 양이 급격히 증가**할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/09f83abe-3da5-40a5-8076-ad0b75c687d9)

`빈번하게 변경된 레코드`를 조회하는 `쿼리`가 실행되면 InnoDB 스토리지 엔진은 `언두 로그`의 `이력`을 

**필요한 만큼 스캔**해야 필요한 레코드를 찾을 수 있어서 `쿼리의 성능`이 **떨어지는 문제도 발생**한다.

**언두 로그의 문제점 개선**

- MySQL `5.7`, `8.0` 버전 업그레이드 부터 **언두 로그 공간 문제점은 완전히 해결**되었다.
- `8.0` 에서는 `언두 로그`를 돌아가면서 **순차적으로 사용**해 `디스크 공간`을 **줄이는 것이 가능**해졌다.

`언두 로그`의 문제가 개선되었다고 해도, MySQL 서버에서 `활성 상태`의 `트랜잭션`이 **장기간 유지되는 것**은

`성능`상 매우 좋지 않다.

따라서, MySQL 서버의 `언두 로그`가 얼마나 `증가`했는지 `모니터링`하는 것이 좋은데,

아래의 `명령어`로 **언두 로그 건수를 확인**할 수 있다.

- MySQL 서버의 `모든 버전`에서 사용 가능한 명령

```sql
mysql> SHOW ENGINE INNODB STATUS \G;
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c8e151e6-b59e-453d-bdb8-dd97e338bb31)

- MySQL `8.0` 버전 부터 사용 가능한 명령

```sql
mysql> SELECT count
			 FROM information_schema.innodb_metrics
			 WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/5bc636c9-3b76-496e-b8b2-4747679c0972)

MySQL `서버`에서 실행되는 `데이터 변경`이 얼마나 많은 데이터를 `변경`하느냐에 

따라서 `평상시` **언두 로그 건수는 상이**할 수 있다.

서버별로 `안정적인 시점`의 **언두 로그 건수를 확인**해 이를 기준으로 언두 로그의 

급증 여부를 모니터링 하는 것이 좋다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/996ea139-f254-4f3b-8e21-4cbb8b1c9737)

### 🫠 언두 테이블스페이스 관리

- `언두 로그`가 저장되는 공간을 **언두 테이블스페이스**라고 한다.
- `언두 테이블 스페이스`는 MySQL 버전별로 많은 변화가 있었다.

`MySQL 5.6` 이전 버전에서는 **언두 로그가 모두 시스템 테이블 스페이스에 저장**됐다.

시스템 테이블 스페이스의 `언두 로그`는 MySQL 서버가 초기화 될때 생성되어 **확장의 한계**가 있었다.

MySQL 5.6 버전부터 생긴 `innodb_undo_tablespaces` 시스템 변수의 값을 **2보다 큰 값으로 설정**하면,

시스템 테이블 스페이스 대신 **별도의 언두 로그 파일을 사용**하게 된다.

`innodb_undo_tablespaces`를 `0`으로 설정하면 **언두 로그가 시스템 테이블스페이스에 저장**된다.

`8.0.14` 버전부터는 이 시스템 변수는 효력이 없어져서 **항상 언두 로그 파일을 사용하도록 개선**되었다.

**언두 테이블 스페이스의 형태**

- `언두 테이블 스페이스`는 `1`개 이상 `128`개 이하의 **롤백 세그먼트**를 가진다.
- `롤백 세그먼트`는 `1`개 이상의 **언두 슬롯**을 가진다.

하나의 `롤백 세그먼트`는 InnoDB의 페이지 크기를 **16바이트로 나눈 값의 개수만큼 언두 슬롯을 가진다.**

하나의 `트랜잭션`이 필요로 하는 `언두 슬롯`의 개수는 

`트랜잭션`이 실행하는 문장(INSERT, UPDATE, DELETE)의 특성에 따라 `최대 4개`까지 사용한다.

일반적으로 `트랜잭션`이 `임시 테이블`을 사용하지 않기 때문에,

하나의 `트랜잭션`은 대략 `2`개 정도의 **언두 슬롯을 필요로 한다고 가정**할 수 있다.

최대 동시 처리 가능한 `트랜잭션`의 개수는 **아래의 수식으로 예측**해볼 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/1046e3aa-e32b-48b6-9cd0-5866a8de14fd)

`16KB InnoDB`에서 기본 설정을 사용한다고 가정하면 대략 `131072`개 정도의 `트랜잭션`을 **동시에 처리할 수 있다.**

일반적인 `서비스`에서는 이 정도 **큰 규모의 동시 트랜잭션**이 필요하진 않을 것이다.

하지만 `기본값`으로 해서 `큰 문제`가 될 건 없으므로, **언두 로그 슬롯이 부족한 것보다는 훨씬 낫다.**

`언두 로그` 관련 `시스템 변수`를 변경해야 할 경우,

적절히 필요한 `동시 트랜잭션`의 개수에 맞게 `언두 테이블스페이스`와 `롤백 세그먼트`의 **개수를 지정**해야 한다.

`MySQL 8.0` 이전까지는 한 번 생성된 `언두 로그`는 변경이 허용되지 않았지만,

`CREATE UNDO TABLESPACE`와 `DROP TABLESPACE` 명령으로 **동적으로 처리가 가능**해졌다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/8f95c50a-f0f6-4918-93bb-c719b6bb50be)

**언두 테이블스페이스 공간 관리**

- `언두 테이블스페이스` 공간 중 불필요하거나 `과도하게 할당`된 `공간`은 **운영체제로 반납**한다.
- `언두 테이블스페이스`의 불필요한 공간을 잘라내는 방법은 `자동`과 `수동`이 있고, 8.0 버전부터 지원한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/258f7b39-70d5-467c-9f91-ad9193290359)

수동으로 `언두 테이블스페이스`를 비활성화해서 **퍼지 스레드에 의해 운영체제 반납을 유도**하려는 경우

아래의 명령어로 `언두 테이블스페이스`를 비활성화 하고, **퍼지 스레드에 의한 반납 이후 다시 활성화** 할 수 있다.

```sql
-- 언두 테이블스페이스 비활성화
mysql> ALTER UNDO TABLESPACE tablespace_name SET INACTIVE;

-- 언두 테이블스페이스 활성화
mysql> ALTER UNDO TABLESPACE tablespace_name SET ACTIVE;
```

### 🤫 체인지 버퍼

- `RDBMS`에서 레코드가 `INSERT` 되거나 `UPDATE` 될 때는 **인덱스를 업데이트 하는 작업도 필요**하다.
- 이 작업은 `디스크`에 `랜덤 I/O`를 유발하여 **테이블에 인덱스가 많다면 많은 자원을 소모**한다.

InnoDB는 변경해야 할 `인덱스 페이지`가 `버퍼 풀`에 있으면 바로 `업데이트`를 수행한다.

그렇지 않다면 `즉시 실행`하지 않고 `임시 공간`에 저장해 두고 `사용자`에게 결과를 반환해, **성능을 향상**시킨다.

이때 사용하는 `임시 메모리 공간`을 `체인지 버퍼`라고 부른다.

사용자에게 `결과`를 전달하기 전에 `중복 여부`를 확인해야 하는 `유니크 인덱스`는 **체인지 버퍼 사용이 불가능**하다.

`체인지 버퍼`에 임시로 저장된 `인덱스 레코드 조각`은 **백그라운드 스레드에 의해 병합**된다.

`MySQL 8.0` 버전 부터는 INSERT, DELETE, UPDATE 작업으로 `키 추가` 또는 `삭제`를 할 경우에도 **버퍼 사용이 가능**해졌다.

MySQL `5.5`  이전 버전 까지는 `체인지 버퍼 기능`을 사용하는 것이 `기본값`이였지만,

`체인지 버퍼`가 비효율적인 경우가 있으므로 `5.5` 버전 부터는 `시스템 변수`로 `컨트롤` 할 수 있게 되었다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/78cf8827-322e-456f-b693-153ce6eb358d)

위의 사진에 나온 `시스템 변수`를 이용하여, `작업`의 `종류`별로 **체인지 버퍼 활성 여부를 결정**할 수 있다.

**체인지 버퍼와 InnoDB 버퍼 풀**

- `체인지 버퍼`는 기본적으로 InnoDB `버퍼 풀`로 설정된 메모리 공간의 `25%`까지 **사용하도록 설정**되있다.
- 필요할 경우 `50%`까지 그 `비율`을 올릴 수 있다.

`체인지 버퍼`가 버퍼 풀의 `메모리`를 **얼마나 사용 중**이고 **얼마나 많은 변경 사항**을 `버퍼링`하고 있는지

보고 싶다면 아래의 `명령어`로 확인할 수 있다.

```sql
mysql> SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
       FROM performance_schema.memory_summary_global_by_event_name
       WHERE EVENT_NAME='memory/innodb/ibufQibuf';
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/38cb14ac-be2f-4dfb-94b1-30e4e445b54d)

### 🤥 리두 로그 및 로그 버퍼

- `리두 로그`는 트랜잭션의 4가지 요소인 `ACID` 중에서 `D(Durable)`에 해당하는 `영속성`과 연관이 있다.
- `리두 로그`는 MySQL 서버의 `비정상 종료`시 데이터를 잃지 않게 해주는 `안전장치`다.

대부분의 `데이터베이스 서버`는 데이터 변경 내용을 `로그`로 기록한다.

`변경된 데이터`를 **데이터 파일에 기록**하려면 `큰 비용`이 들기 때문에, `쓰기 비용`이 낮은 **리두 로그**를 가지고 있다.

MySQL 서버가 `비정상 종료`된다면, InnoDB 스토리지 엔진의 데이터 파일은

**두 가지 종류의 일관되지 않은 데이터**를 가질 수 있다.

1. `커밋`됐지만 데이터 파일에 **기록되지 않은 데이터**
2. `롤백`됐지만 데이터 파일에 **이미 기록된 데이터**

1번 문제의 경우 `해결`이 굉장히 쉽다.

`리두 로그`에 **저장된 데이터를 데이터 파일에 다시 복사**하기만 하면 된다.

2번의 경우에는 `문제`가 조금 복잡해진다.

`리두 로그`만으로는 해결이 `불가능`하기 때문에 **변경되기 전 데이터를 가진 언두 로그의 내용**을 가져와서

`데이터 파일`에 `복사`하는 것으로 해결할 수 있다.

2번 문제는 `리두 로그`가 필요없는 것이 아닌가 싶을 수 있는데,

최소한 `변경 사항`이 `커밋` 되었는지 `롤백` 되었는지 아니면 `트랜잭션 실행 중간`인지 

확인해야 하므로 **꼭 필요하다.**

`리두 로그`는 트랜잭션 `커밋`시 **즉시 디스크로 기록**되도록 `설정`하는 것이 좋다.

그래야만 `서버`가 `비정상`적으로 종료됐을 때 **직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록**된다.

`트랜잭션`이 `커밋`될 때마다 `리두 로그`를 디스크에 기록하는 작업은 꽤 많은 `부하`를 `유발`한다.

따라서 `리두 로그`를 어느 주기로 디스크에 `동기화`할지는 **시스템 변수로 컨트롤** 할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/70319808-5936-471a-be08-f73a71f3e9f8)

이 시스템 변수가 `0`이나 `2`로 설정된다고 해서 `디스크 동기화`가 **1초 간격으로 실행되는 것은 아니다.**

`스키마 변경`을 위한 `DDL` 실행시 **리두 로그가 디스크로 동기화** 되기 때문에 더 짧아질 수 있다.

`DDL`은 자주 실행되지 않기 때문에, `리두 로그`는 최대 `1초` 정도 **손실이 발생할 수 있다는 점**이 중요하다.

**리두 로그 파일의 크기**

- `리두 로그 파일`들의 전체 크기는 **버퍼 풀의 효율성을 결정**하므로 신중히 결정해야 한다.
- `리두 로그 파일`의 `크기`는 **innodb_log_file_size** 변수로 결정한다.
- `리두 로그 파일`의 `개수`는 **innodb_log_files_in_group** 변수로 결정한다.

전체 **리두 로그 파일**의 `크기`는 위의 `두 시스템 변수의 곱`으로 결정된다.

사용량이 매우 많은 DBMS 서버라면 `리두 로그`의 **기록 작업이 큰 문제가 되는 경우가 많다.**

이런 경우에는 `ACID 속성`을 보장하는 수준에서 `버퍼링` 하는 것이 좋다.

`리두 로그 버퍼링`에 사용되는 공간을 `로그 버퍼`라고 하며, 기본 값인 `16MB` 수준에서 설정하는 것이 좋지만 

`BLOB`이나 `TEXT`와 같이 **큰 데이터 변경이 자주 필요**하다면 `더 크게 설정`해주는 것이 `좋다.`

### 🤥 리두 로그 아카이빙

- MySQL `8.0` 버전부터 InnoDB 스토리지 엔진의 `리두 로그`를 `아카이빙` 할 수 있게 되었다.
- MySQL `엔터프라이즈 백업`이나 `Xtrabackup` 툴은 데이터 파일을 복사하면서 InnoDB 스토리지 엔진의 리두 로그에 쌓인 내용을 `계속 추적`하고 새로 추가된 `리두 로그 엔트리`를 `복사`한다.

`데이터 파일`을 복사하는 동안 추가된 `리두 로그 엔트리`를 같이 `백업`하지 못할 경우,

복사된 `데이터 백업 파일`이 `일관된 상태`를 **유지하지 못하기 때문**에 이런 기능을 제공하고 있다.

하지만 `MySQL 서버`에 유입되는 `데이터 변경`이 너무 많을 경우, **리두 로그가 매우 빠르게 증가**하여

`백업 툴`이 새로 추가 되는 `리두 로그 내용`을 복사하기도 전에 덮어 쓸 수도 있다.

이런 문제를 해결하기 위해 나온 방법이 `리두 로그 아카이빙` 기능이며,

데이터 변경이 많아서 `리두 로그`가 덮어쓰인다고 하더라도 **백업이 실패하지 않도록 도와준다.**

`백업 툴`이 `리두 로그 아카이빙`을 사용하려면 아카이빙 된 **리두 로그가 저장될 디렉터리**를

`innodb_repo_log_archive_dirs` 변수에 `설정`해야 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/421c56c4-e2f9-4bba-8f8a-0d225ebe0d42)

`디렉터리`가 준비되면, 아래의 명령어로 `리두 로그 아카이빙`을 시작하도록 `사용자 정의 함수`를 호출하면 된다.

```sql
mysql> DO innodb_redo_log_archive_start('backup', '20200722');
```

`첫 번째 파라미터`는 **리두 로그를 아카이빙할 디렉터리에 대한 레이블**이다.

`두 번째 파라미터`는 **서브 디렉터리의 이름**이다. 필수 값은 아니다.

`INSERT`를 실행하고 리두 로그 아카이빙 `디렉터리`를 확인하면 `리두 로그`의 내용이 `아카이빙 파일`로

**복사되어 있는 것을 확인**할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c356640d-ff5a-402a-8fda-c38dbfadec5c)

`리두 로그 아카이빙`을 종료하고 싶다면, `innodb_repo_log_archive_stop` 함수를 호출하면 된다.

```sql
mysql> DO innodb_repo_log_archive_stop();
```

`함수`를 `호출`한다고 해서 `리두 로그 아카이빙` 파일이 삭제되는 것은 아니므로 `수동 삭제`해야 한다.

`리두 로그 아카이빙`을 시작한 `커넥션`은 **그대로 유지되어야 동작에 문제가 없다.**

`아카이빙`을 시작한 `세션`이 **비정상적으로 종료**되면, `아카이빙` 된 리두 로그가 **쓸모가 없어지기 때문**에

InnoDB `스토리지 엔진`에 의해 `리두 로그 아카이빙`은 **중단되고 파일도 자동으로 삭제**한다.

따라서 `정상적`으로 `리두 로그 아카이빙`을 마치려면,

`innodb_redo_log_archive_start` 함수를 호출하고 **커넥션을 유지**하고 `작업이 완료`되었을때

`innodb_repo_log_archive_stop` 함수를 호출하여 **아카이빙을 정상 종료** 해야한다.

### 😶‍🌫️ 리두 로그 활성화 및 비활성화

- InnoDB 스토리지 엔진의 `리두 로그`는 **항상 활성화** 되어 있다.
- `데이터 파일`은 즉시 디스크로 동기화 되지 않지만, `리두 로그`는 **항상 디스크로 기록**된다.

MySQL 8.0 이전 버전까지는 `수동`으로 `리두 로그`를 **비활성화** 할 수 없었다.

따라서, 이제는 `데이터 복구`나 `대용량 데이터`를 한 번에 적재하는 경우 **리두 로그를 비활성화**하여,

`데이터`의 **적재 시간**을 줄일 수 있게 되었다.

```sql
-- 리두 로그 비활성화
mysql> ALTER INSTANCE DISABLE INNODB REDO_LOG;

-- 리두 로그 활성화
mysql> ALTER INSTANCE ENABLE INNODB REDO_LOG;
```

`리두 로그`의 활성화 여부를 변경하고, **innodb_redo_log_enabled** 상태 값으로 `결과`를 `확인`할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/376ecb35-5e7f-4054-b36d-752d0dcf6278)

`리두 로그`를 비활성화 하고 `데이터 적재 작업`을 실행했다면 작업 후 `리두 로그`를 `활성화` 해야 한다.

`리두 로그` 비활성화 상태에서는 마지막 `체크 포인트` 이후의 **데이터는 모두 복구가 불가능**하다.

MySQL 서버의 데이터가 마지막 `체크 포인트 시점`의 **일관된 상태가 아닐 경우 더 큰 문제**가 `발생`한다.

마지막 `체크포인트`와 서버 비정상종료 시간 사이에 서버의 `데이터 파일`은 **다양한 시점의 데이터**를 가지게 된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/73dcbc74-4e57-4dba-8590-e47430eb5db9)

`서비스`에서 `데이터`가 중요하지 않더라도, `리두 로그`를 `비활성화` 하는 것은 좋지 않다.

`innodb_flush_log_at_trx_commit`의 값을 1이 아닌 0이나 2로 설정하는 것이 좋다.

### 🥵 어댑티브 해시 인덱스

- 일반적으로 `인덱스`는 **테이블에 사용자가 생성해둔 B-Tree 인덱스**를 의미한다.
- `어댑티브 해시 인덱스`는 사용자가 수동으로 생성하는 인덱스가 아니다.
- InnoDB 스토리지 엔진이 `사용자`가 **자주 요청하는 데이터**에 대해 `자동`으로 `생성`하는 `인덱스`이다.
- `innodb_adaptive_hash_index` 시스템 변수로 `활성화` 또는 `비활성화`가 가능하다.

`B-Tree 인덱스`에서 특정 값을 찾는 과정은 과연 빠를까?

`B-Tree 인덱스`에서 특정 값을 찾으려면 `루트 노드`를 거쳐서 

`브랜치 노드` 그리고 `리프 노드`까지 찾아가야 한다.

이런 작업을 동시에 `많은 수의 스레드`가 실행하면 컴퓨터의 

`CPU`는 부하가 걸리게 되고 `쿼리`의 `성능`이 떨어진다.

`어댑티브 해시 인덱스`는 이런 `B-Tree`의 **검색 시간을 줄여주기 위해 도입**되었다.

자주 읽히는 `데이터 페이지`의 `키` 값을 이용해 `해시 인덱스`를 만들고 필요할 때마다, 

`레코드`가 저장된 `데이터 페이지`를 바로 찾아갈 수 있다.

`해시 인덱스`는 인덱스 키 값과 해당 인덱스 키 값이 저장된 `데이터 페이지` 주소의 쌍으로 관리된다.

`B-Tree 인덱스`의 **고유 번호**와 B-Tree 인덱스의 **실제 키 값 조합**으로 `생성`된다.

InnoDB 스토리지 엔진에서 `어댑티브 해시 인덱스`는 **하나만 존재**한다.

데이터 페이지 주소는 `실제 키` 값이 저장된 데이터 페이지의 `메모리 주소`를 가진다.

따라서, `어댑티브 해시 인덱스`는 `버퍼 풀`에 올려진 **데이터 페이지 내에서만 관리**된다.

버퍼 풀에서 `데이터 페이지`가 사라지면 `어댑티브 해시 인덱스`에서도 **해당 페이지 정보가 사라진다.**

어댑티브 해시 인덱스는 얼마나 성능에 도움이 될까?

어댑티브 해시 인덱스를 활성화 했을때 단순한 쿼리는 성능 향상에 도움이 되는 것을 볼 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/fb9b3d41-b723-4ed9-8cc9-e7aa0cf95679)

`B-Tree`의 루트 노드 부터 검색이 많이 줄어서 InnoDB `내부 잠금(세마포어)` 횟수도 **획기적으로 줄어든다.**

예전 버전에서는 `어댑티브 해시 인덱스`는 하나의 메모리 객체여서 `경합`이 상당히 심했었다.

`MySQL 8.0` 부터는 이 문제(`내부 잠금 경합`) 해결을 위해,

어댑티브 해시 `인덱스`의 `파티션 기능`을 제공하고 `innodb_adaptive_hash_index_parts` 변수로 

`파티션의 개수`를 지정할 수 있다.

이 `변수`의 **기본 값**은 `8`이며, 어댑티브 해시 인덱스가 `성능`에 많은 도움을 준다면

`파티션 개수`를 더 많이 설정하는 것도 `어댑티브 해시 인덱스`의 **내부 잠금 경합을 줄여준다.**

하지만 `어댑티브 해시 인덱스`가 성능에 크게 도움이 되지 않아 `비활성화` 하는 경우도 많다.

그렇다면 어떤 경우에 `어댑티브 해시 인덱스`를 활성화해야할까?

**비활성화 해야 하는 경우**

- `디스크 읽기`가 많은 경우
- 특정 패턴의 `쿼리`가 많은 경우(`조인` or `LIKE` 패턴 검색)
- **매우 큰 데이터를 가진 테이블**의 `레코드`를 폭 넓게 읽는 경우

**활성화 해야 하는 경우**

- `디스크`의 데이터가 InnoDB `버퍼 풀 크기`와 **비슷한 경우**
- 동등 조건 검색(`동등` 비교와 `IN` 연산자)이 많은 경우
- `쿼리`가 데이터 중에서 `일부 데이터`에만 집중되는 경우

`어댑티브 해시 인덱스`는 데이터 페이지를 `메모리 내`에서 `접근`하는 것을 **더 빠르게 만든다.**

`데이터 페이지`를 `디스크`에서 읽어오는 것이 빈번하다면 **아무런 도움이 되지 않는다.**

`어댑티브 해시 인덱스` 역시 저장 공간을 사용하며, 때로는 `상당히 큰 공간`을 `차지`할 수 있다.

따라서 `불필요`한 경우 `제거`되야 한다.

하지만, `어댑티브 해시 인덱스`가 활성화되면 InnoDB 엔진은 키 값이 `해시 인덱스`에 있는지 여부와 관계없이

무조건 `해시 인덱스`에 검색을 해보게 된다.

**어댑티브 해시 인덱스와 테이블 삭제 작업의 관계**

- 테이블의 `변경`이나 `삭제`시에는 테이블이 가진 모든 데이터 페이지의 내용을 `어댑티브 해시 인덱스`에서 삭제 해야한다.
- 따라서 테이블이 `삭제`되거나 `스키마`가 변경되는 경우 상당히 많은 CPU 자원을 사용하게 된다.

그렇다면 `어댑티브 해시 인덱스`가 우리 **서비스 패턴에 맞는지 확인**해야 할 `필요`가 생긴다.

어떻게 `어댑티브 해시 인덱스` 사용 여부를 판단할 수 있을까?

MySQL 서버의 `상태 값`들을 **살펴보는 것이 가장 판단하기 좋은 방법**이다.

```sql
mysql> SHOW ENGINE INNODB STATUS\G;
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/f7d58ff7-3567-40b3-abc2-d648f05d83cb)

`hash searches/s` 의 값이 0으로 표시되면, `어댑티브 해시 인덱스`가 비활성화  되어 있는 것이다.

`searches` 는 쿼리의 실행회수가 아니라 `쿼리`가 처리되기 위해 **내부적으로 키 값을 검색한 횟수**이다.

`어댑티브 해시 인덱스`의 효율은, 여러 지표를 `종합`해서 `판단`해야한다.

`CPU 사용량`이 높지 않은데 `히트율`도 낮다면 어댑티브 해시 인덱스는 **비활성화 하는 것이 나을 수 있다.**

`어댑티브 해시 인덱스`의 **메모리 사용량**은 `performance_schema`를 이용해서 확인할 수 있다.

```sql
mysql> SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
       FROM performance_schema.memory_summary_global_by_event_name
       WHERE EVENT_NAME='memory/innodb/adaptive hash index';
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d5413eaf-58bd-49d5-bece-9cd20619670d)

### ☺️ InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- 예전에는 `MyISAM`이 **기본 스토리지 엔진으로 사용**되는 경우가 많았다.
- `5.5` 버전 부터는 InnoDB 스토리지 엔진이 기본으로 채택 되었지만, `시스템 테이블`은 `MyISAM` 테이블을 사용했다.
- `8.0` 업그레이드 후 MySQL 서버의 모든 `시스템 테이블`은 InnoDB `스토리지 엔진`을 지원하도록 `개선`되었다.

`MEMORY` 스토리지 엔진은 동시 처리 성능에 있어서 InnoDB `스토리지 엔진`보다 현저히 성능이 약하다.

`하나의 스레드`에서만 데이터를 읽고 쓴다면 InnoDB `스토리지 엔진`보다 빠르겠지만,

`온라인 트랜잭션 처리`가 데이터베이스 서버의 주목적으로 사용된다면 `테이블 수준`의 `잠금`으로 `성능`이 떨어진다.

MySQL 서버는 사용자의 `쿼리`를 처리하기 위해 `내부적`으로 `임시 테이블`을 `사용`할 수 있다.

5.7 버전까지는 `MEMORY` 스토리지 엔진이 내부 `임시 테이블 용도`로 사용되었다.

하지만 `가변 길이 타입`의 컬럼을 지원하지 않는 문제로 `8.0`부터 `TempTable` 스토리지 엔진에게

그 역할을 물려주게 되었고, `기본 셋팅`으로 사용하고 있다.

`internal_tmp_mem_storage_engine` 시스템 변수로 임시 테이블에 사용할 엔진을 정할 수 있다.

`TempTable`이 기본 값이며 `TempTable 엔진`을 사용하겠다는 셋팅이다.

`MEMORY` 스토리지 엔진은 이전 버전의 `호환성 유지 차원`에서 삭제되지 않았을 뿐

추후 `릴리즈`가 된다면 **제거될 것으로 보인다.**

### 🤪 MyISAM 스토리지 엔진 아키텍처

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c81133e3-5a93-4be1-a243-433d72e01c3b)

**키 캐시**

- InnoDB의 `버퍼 풀`과 비슷한 역할을 하는 것이 `MyISAM`의 `키 캐시`이다.
- MyISAM `키 캐시`는 인덱스만을 대상으로 작동하고 `인덱스`의 디스크 쓰기 작업에 대해서만 부분적으로 `버퍼링`을 한다.

`키 캐시`가 얼마나 효율적으로 작동하는 지는 아래의 `수식`으로 `확인`할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/a405b134-1553-4c92-aeba-096f22379561)

이 수식에서 `Key_reads`는 **인덱스를 디스크에서 읽어 들인 횟수**를 뜻하며,

`Key_read_requests`는 **키 캐시로부터 인덱스를 읽은 횟수**를 뜻한다.

`Key_reads`와 `Key_read_requests` 등의 상태 변수를 확인하려면 아래의 `명령어`로 `확인`할 수 있다.

```sql
mysql> SHOW GLOBAL STATUS LIKE 'Key%';
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/8b5fb252-b09d-4964-8f2c-278d46501843)

`메뉴얼`에서는 일반적으로 `키 캐시`를 이용한 쿼리의 비율을 `99% 이상`으로 `유지`하라고 `권장`하고 있다.

`히트율`이 `99%` 미만일 경우 `키 캐시`를 조금 더 크게 설정하는 것이 좋다.

**운영 체제와 키 캐시 메모리 공간**

- `32비트 운영체제`는 하나의 키 캐시에 `4GB` 이상의 메모리 공간을 설정할 수 없다.
- `64비트 운영체제`의 경우 `OS_PER_PROCESS_LIMIT` 값에 설정된 크기만큼 할당 가능하다.

제한 값 이상의 `키 캐시`를 `할당`하고 싶다면 `기본 키 캐시` 이외의 키 캐시 공간을 설정해야 한다.

기본 키 캐시 공간을 설정하는 `파라미터`는 `key_buffer_size`로 할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/8c3e6e47-35a8-4e94-82f2-2729a3a48d1e)

`kbuf_board`와 `kbuf_comment`라는 이름의 키 캐시가 `2GB`씩 생성된다.

기본 키 캐시 이외의 `명명된 캐시 영역`은 **설정 없이는 사용되지 않는다.**

어떤 인덱스를 `캐시`할지 `MyISAM 스토리지 엔진`에게 알려줘야 한다.

아래의 명령어로 각 `키 캐시`에 게시판 테이블의 인덱스와 코멘트 테이블의 `인덱스`가 `캐시`되도록 할 수 있다.

```sql
mysql> CACHE INDEX db1.board, db2.board IN kbuf_board; 
mysql> CACHE INDEX db1.comment, db2.comment IN kbuf_comment;
```

### 😏 운영체제의 캐시 및 버퍼

- MyISAM 테이블의 `인덱스`는 키 캐시를 이용해 `디스크`를 검색하지 않고도 빠르게 검색이 가능하다.
- `테이블`의 데이터에 대해서는 `디스크`로부터 I/O를 해결해 줄 만한 어떠한 `캐시`나 `버퍼링 기능`도 없다.

MyISAM 테이블의 `데이터 읽기`나 `쓰기 작업`은 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청된다.

물론 다수의 `운영체제`는 `디스크`로부터 읽고 쓰는 파일에 대한 캐시나 `버퍼링 메커니즘`을 가지고 있기 때문에

매번 `디스크 읽기 작업`을 위해 **디스크의 파일을 읽지는 않는다.**

MyISAM `테이블`을 주로 사용하는 경우에는 `운영체제`가 사용할 수 있는 `캐시 공간`을 위해 충분히

`메모리`를 비워둬야 **성능 상 문제를 최대한 방지**할 수 있다.

일반적으로 `키 캐시`는 최대 물리 메모리의 `40%` 이상을 넘지 않게 `설정`하는 것이 좋다.

### ☺️ 데이터 파일과 프라이머리 키(인덱스) 구조

- MyISAM 테이블은 `프라이머리 키`에 의한 `클러스터링` 없이 데이터 파일이 `힙 공간`처럼 쓰인다.
- 레코드 저장시 `프라이머리 키` 값과 무관하게 저장되는 순서대로 `데이터 파일`에 `저장`된다.
- MyISAM 테이블에 저장되는 레코드는 `ROWID`라는 `물리적인 주소`를 가진다.

`ROWID`는 **가변 길이**와 **고정 길이** 두 가지 방법으로 저장될 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/6c67fd01-c12a-4b6a-8b84-9ea2cdbfec3f)

### 🤓 MySQL 로그 파일

- 서버의 상태를 진단할 수 있는 도구들이 많이 지원되지만 많은 지식이 필요한 경우가 많다.
- 로그 파일을 잘 살펴보면 깊은 내부 지식 없이도 상태나 부하를 일으키는 원인을 쉽게 찾을 수 있다.

### 😶‍🌫️ 에러 로그 파일

- `MySQL`이 실행되는 도중에 발생하는 `에러`나 `경고 메시지`가 출력되는 `로그 파일`이다.
- `my.cnf`에서 `log_error` 이름의 **파라미터로 정의된 경로에 생성**된다.
- 설정 파일에 별도로 정의되지 않은 경우 `데이터 디렉터리`에 `.err` 확장자가 붙은 `파일`로 `생성`된다.

### 😛 MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지

- `MySQL`의 설정 파일을 변경하거나 `데이터베이스`가 비정상 종료된 후 다시 서버를 시작했다면 `에러 로그 파일`의 내용을 확인해야 한다.
- `MySQL` 서버가 정상적으로 기동되었고, 특별한 `에러`나 `경고성 메시지`가 없다면 **정상 적용된 것으로 판단**하면 된다.
- `특정 변수`가 무시 된 경우에는 `서버`는 정상 기동하지만, 해당 `파라미터`가 적용되지 못한 것이다.
- `변수명`이 인식되지 않거나 `파라미터 값`을 **인식하지 못하는 경우**에는 `에러 메시지`를 출력하고 서버가 실행되지 않는다.

### 😫 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지

- `문제`가 있어서 `복구`되지 못할 때는 `에러 메시지`를 출력하고 `MySQL`은 `종료`된다.
- 이 단계에서 `문제`가 발생한다면 상대적으로 해결하기가 `어려운 문제`일 때가 많다.

### 😖 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지

- **쿼리 도중 발생하는 문제점**은 `사전 예방`이 어렵다.
- 주기적으로 `에러 로그 파일`을 `검토`하는 과정에서 알게 되며, `실행 중` **발생한 에러나 복제**에서 문제가 될 만한 `경고 메시지`가 **에러 로그에 기록**된다.
- 자주 `에러 로그` 파일을 검토하면 **숨겨진 문제점을 해결하는데 도움**이 된다.

### 😗 비정상적으로 종료된 커넥션 메시지(Aborted connection)

- 중간에 `네트워크 문제`가 있어서 **의도하지 않게 접속이 끊기면 기록되는 메시지**이다.
- 이런 메시지가 아주 많이 기록된다면 `애플리케이션`의 `커넥션 종료 로직`을 `검토`해볼 필요는 있다.
- `max_connect_errors` 시스템 변수값이 너무 낮게 설정된 경우 `클라이언트 프로그램`이 아예 접속하지 못하는 경우가 생길 수 있다.
- `max_connect_errors` 변수 값을 증가시키기 전에 이 `에러`가 **발생한 원인**을 살펴보는 것이 좋다.

### 😋 InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지

- InnoDB의 테이블 `모니터링`, `락 모니터링`, `엔진 상태 조회 명령` 중 상대적으로 큰 메시지를 에러 로그 파일에 기록한다.
- InnoDB의 모니터링을 `활성화` 상태로 두고 유지하면 `에러 로그 파일`이 너무 커져서 `공간`을 다 사용할지도 모른다.
- `모니터링`을 사용한 후에는 다시 `비활성화` 하는 것이 좋다.

### 🫠 MySQL의 종료 메시지

- 아무도 모르게 `MySQL`이 `종료`되거나 `재시작`되는 경우가 있다.
- `에러 로그 파일`에서 MySQL이 왜 종료되었는지 확인하는 것이 유일하게 `원인 파악`을 할 수 있는 `방법`이다.
- `종료 관련 메시지`가 없거나 `스택 트레이스`와 같은 내용이 출력되면 `세그먼테이션 폴트`로 비정상 종료 된 것이다.
- `세그먼테이션 폴트`가 원인이라면 `스택 트레이스`의 **내용을 최대한 참조**해서 `버전 업그레이드`나 `회피책`을 찾는 것이 필요하다.

### 🤧 제너럴 쿼리 로그 파일

- `쿼리 로그`를 활성화하면 `쿼리`를 `쿼리 로그 파일`로 기록해서 검토할 수 있다.
- `슬로우 쿼리 로그`와는 달리 `제너럴 쿼리 로그`는 **실행되기 전에 쿼리 요청시 바로 기록**된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/502af130-0e5c-4819-a21b-88dc7d2770bd)

`쿼리 로그 파일`의 `경로`는 `general_log_file` 이라는 이름의 `파라미터`에 설정되어 있다.

쿼리 로그를 파일이 아닌 `테이블`에 **저장하는 옵션도 설정**할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c36cce2e-33bf-4642-be61-06961c20d11e)

### ☺️ 슬로우 쿼리 로그

- `쿼리 튜닝`을 위해 **어떤 쿼리를 검토해야 할지 판단하는 것**은 상당히 어렵다.
- `서비스`에서 사용되는 쿼리 중 어떤 `쿼리`가 문제일지 판단하는 것은 **슬로우 쿼리 로그가 많은 도움이된다.**
- `슬로우 쿼리 로그 파일`에는 `long_query_time` 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다.

`슬로우 쿼리 로그`는 **실제 쿼리를 실행하고 소요된 시간을 기준으로 기록**하기 때문에, 

반드시 `쿼리`가 정상적으로 실행되어야 `기록`될 수 있다.

`log_output` 옵션을 이용해서 `슬로우 쿼리 로그`를 **파일로 기록할지 테이블로 기록할지 선택**할 수 있다.

`log_output` 옵션을 `TABLE`, `FILE` 값을 가질 수 있고 `FILE`로 설정하면 **파일에 기록**된다.

`log_output` 옵션을 `TABLE`로 설정해도 `slow_log` 테이블과 `general_log` 테이블은 

`CSV 스토리지 엔진`을 사용하므로, **CSV 파일로 저장하는 것과 동일하게 작동**한다.

다만 위와 같이 설정하면, `슬로우 쿼리 로그`에 출력되는 내용이 `상당히 혼란`스럽다.

`MySQL`의 잠금 처리는 `엔진 레벨`과 `스토리지 엔진 레벨`의 두 가지 `레이어`로 처리되기 때문이다.

`MEMORY` 스토리지 엔진은 별도의 `스토리지 엔진 레벨`의 `잠금`을 가지지 않기 때문에,

`슬로우 쿼리 로그`에 출력되는 내용이 `혼란`스러울 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/90681c6b-9870-44ab-b274-35b10b497abc)

위의 `슬로우 쿼리 로그`의 내용을 간단히 `해석`해보면 아래와 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/55a85ea6-f540-412d-b051-0c7b5fb2f30f)

`MyISAM`이나 `MEMORY` 스토리지 엔진은 **MVCC와 같은 메커니즘이 없다.**

따라서 `SELECT 쿼리`도 `Lock_time`이 **1초 이상 소요 될 가능성**이 있다.

InnoDB 테이블에 대한 `SELECT 쿼리`에 대해서도 **Lock_time이 상대적으로 큰 값이 발생**할 수 있다.

이는 `MySQL 엔진 레벨`에서 설정한 테이블 잠금 때문일 가능성이 높기 때문에 InnoDB `테이블`에만 `접근`하는 쿼리 문장의 **슬로우 쿼리 로그의 Lock_time 값은 튜닝이나 쿼리 분석에 도움이 되지 않는다.**

`슬로우 쿼리` 또는 `제너럴 로그 파일`의 내용이 상당히 많아서 하나씩 검토하기 어렵다면,

`Percona`에서 개발한 `Percona Toolkit`에서 제공하는 `pt-query-digest` 스크립트로 살펴볼 수 있다.

### 🙂 슬로우 쿼리 통계

- `분석 결과`의 최상단에 표시된다.
- 모든 쿼리를 대상으로 `슬로우 쿼리` 로그의 **실행**시간, `잠금 대기 시간` 등에 대해 **평균** 및 **최소/최대 값**을 표시한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/5efe6fae-2945-407a-b342-9c273d6c6bcf)

### 🙃 실행 빈도 및 누적 실행 시간순 랭킹

- 각 `쿼리`별로 `응답 시간`과 `실행 횟수`를 보여준다.
- `pt-query-digest` 명령 실행 시 `—-order-by` 옵션으로 `정렬 순서`를 변경할 수 있다.
- `Query ID`는 실행된 쿼리 문장을 `정규화`해서 만든 `해시 값`이다.
- **같은 모양**의 `쿼리`라면 `Query ID`도 동일하다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/07e93490-49d8-478e-ba7b-931d28190937)

### 😈 쿼리별 실행 횟수 및 누적 실행 시간 상세정보

- `Query ID`별 쿼리를 `쿼리 랭킹`에 표시된 순서대로 **자세한 내용을 보여준다.**
- 실제 상세한 `쿼리 내용`은 **개별 쿼리의 정보를 확인**해봐야 한다.
- 여기서는 `쿼리`가 얼마나 `실행`됬는지, 쿼리의 `응답 시간`에 대한 **히스토그램 같은 상세한 내용을 볼 수 있다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/110ad9d3-0add-44e1-8d9d-c808e7bb51c0)
