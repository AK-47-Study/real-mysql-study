### 🤕 MySQL 엔진 아키텍처

- `MySQL` 서버는 `MySQL 엔진`, `스토리지 엔진`으로 구분할 수 있다.
- 스토리지 엔진은 `핸들러 API`를 만족하면 누구든지 `스토리지 엔진`을 `구현`해서 `사용`할 수 있다.
- MySQL 서버는 기본적으로 `InnoDB 스토리지 엔진`, `MyISAM 스토리지 엔진`을 제공한다.

MySQL 서버는 다른 `DBMS`에 비해 `구조`가 `독특`하다.

이로 인해 누리는 혜택도 있지만, 다른 `DBMS`에서 문제되지 않을 것들이 `문제`가 되기도 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/876d770f-617e-4a45-b961-5fc9d3a84d80)

- `MySQL`은 대부분의 프로그래밍 언어로부터 `접근 방법`을 지원한다.
- 대표적으로 `Java` 진영은 `JDBC`를 이용해 `MySQL`에 접근할 수 있다.

### 🤚🏼 MySQL 엔진 & 스토리지 엔진

**MySQL 엔진**

- `MySQL 엔진`은 클라이언트의 `접속 요청` 및 `쿼리 요청`을 처리하는 **커넥션 핸들러**와 **SQL 파서** 및 **전처리기**, 쿼리의 최적화를 돕는 **옵티마이저**로 구성되어 있다.
- 표준 `SQL(ANSI SQL)` 문법으로 작성된 `SQL`은 다른 `DBMS`와 호환이 가능하다.

**스토리지 엔진**

- 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 담당한다.
- MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.

예를 들어, 아래와 같이 `테이블`이 사용할 `스토리지 엔진`을 `지정`하면 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 정의된 `스토리지 엔진`이 `처리`한다.

```sql
mysql> CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

각 `스토리지 엔진`은 성능 향상을 위해 `키 캐시`(MyISAM 스토리지 엔진)나 `InnoDB 버퍼 풀`(InnoDB 스토리지 엔진) `기능`을 `내장`하고 있다.

### 🤓 핸들러 API

- `MySQL` 엔진의 `쿼리 실행기`에서 데이터를 쓰거나 읽을 때는 `스토리지 엔진`에 `요청`을 해야한다.
- 이러한 요청을 `핸들러 요청`이라고 하고, 여기서 사용되는 API가 `핸들러 API`다.
- `InnoDB 스토리지 엔진`도 핸들러 API를 사용해 `MySQL 엔진`과 데이터를 주고받는다.

`핸들러 API`를 통해 얼마나 많은 데이터 작업이 있었는지 확인 하려면 `아래의 명령`으로 확인할 수 있다.

```sql
mysql> SHOW GLOBAL STATUS LIKE 'Handler%';
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/98d79fa0-d149-46bd-85c7-41570eb4d766)

### 🤢 MySQL 스레딩 구조

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9e0e708f-dd63-4240-a83b-02ccfedfbce2)

- `MySQL 서버`는 **프로세스** 기반이 아니라 `스레드 기반`으로 작동한다.
- 작동하는 스레드는 `포그라운드(Foreground)` 스레드와 `백그라운드(Background)` 스레드로 구분할 수 있다.

`MySQL 서버`에서 실행 중인 `스레드`의 목록이 궁금하다면, 아래의 `쿼리`로 확인할 수 있다.

```sql
## 실행 중인 스레드의 목록 -> performance_schema 데이터베이스의 threads 테이블을 통해 확인

mysql> SELECT thread_id, name, type, processlist_user, processlist_host 
FROM performance_schema.threads ORDER BY type, thread_id;
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/aad77550-2f93-49ab-84c6-b6f3048204c5)

현재 `실행중인 스레드`는 **44**개이며, **41**개의 `백그라운드 스레드`와 **3**개의 `포그라운드 스레드`로 구성되어 있다.

`thread/sql/one_connection` 스레드가 실제 사용자의 요청을 처리하는 `포그라운드 스레드`이다.

`백그라운드 스레드`의 개수는 MySQL `서버 설정`에 따라 `가변적`일 수 있다.

`동일한 이름의 스레드`가 `2개` 이상씩 보이는 경우 MySQL 서버의 설정에 의해 `여러 스레드`가 **동일 작업을 병렬로 처리**하는 경우에 나타난다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/199c59ec-d7d8-4aa4-a803-4adcae763fd1)

### 🏀 포그라운드 스레드(클라이언트 스레드)

- `포그라운드 스레드`는 최소한 `MySQL` 서버에 접속된 **클라이언트의 수**만큼 `존재`한다.
- 각 `클라이언트` 사용자가 요청하는 `쿼리 문장`을 처리한다.
- `클라이언트` 사용자가 작업을 마치고 `커넥션`을 `종료`하면 `스레드 캐시`로 되돌아 간다.
- `스레드 캐시`에 일정 개수 이상의 대기 중인 스레드가 있다면, `스레드 캐시`에 넣지 않고 `스레드`를 `종료`한다.

`스레드 캐시`에 유지할 수 있는 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정할 수 있다.

`포그라운드 스레드`는 데이터를 `MySQL`의 **데이터 버퍼**나 **캐시**로부터 가져오고, `버퍼`나 `캐시`에 없는 경우 직접    `디스크`의 데이터나 `인덱스 파일`로부터 데이터를 읽어와서 작업을 처리한다.

`MyISAM` 테이블은 **디스크 쓰기 작업**까지 `포그라운드 스레드`가 처리하고,

`InnoDB` 테이블은 **데이터 버퍼**나 **캐시**까지만 `포그라운드 스레드`가 처리하고, 나머지 **버퍼**로부터 **디스크**까지 기록하는 작업은 `백그라운드 스레드`가 처리한다.

`MyISAM`도 지연된 쓰기는 있지만, 일반적인 방식은 아니다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/4f1da89d-d877-4f41-8cdd-fd7b13b69687)

### 😕 백그라운드 스레드

`InnoDB`는 아래와 같이 여러 가지 작업이 백그라운드로 처리된다.

- `인서트 버퍼(Insert Buffer)`를 **병합**하는 스레드
- **로그**를 **디스크**로 `기록`하는 스레드
- `InnoDB 버퍼 풀`의 데이터를 디스크에 기록하는 스레드
- `데이터`를 버퍼로 읽어 오는 스레드
- `잠금`이나 `데드락`을 모니터링하는 스레드

모두 `중요한 역할`을 수행하고 있지만, 가장 중요한 것은 `로그 스레드`와 `쓰기 스레드`라고 볼 수 있다.

MySQL `5.5` 버전부터 `데이터 쓰기 스레드`와 `데이터 읽기 스레드`의 개수를 `2개` 이상 지정할 수 있다.

`innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 스레드의 개수를 설정한다.

`읽는 작업`은 주로 `클라이언트 스레드`가 처리하기 때문에 많은 스레드가 필요없지만,

`쓰기 스레드`는 아주 많은 작업을 백그라운드로 처리하므로 `내장 디스크`의 경우 **2~4**, 

`DAS` & `SAN`과 같은 스토리지를 사용한다면 **충분히 설정**하는 것이 좋다.

`사용자`의 요청을 처리하는 도중 `데이터 쓰기 작업`은 `지연(버퍼링)`되어 처리 될 수 있다.

하지만 데이터의 `읽기 작업`은 절대 지연될 수 없다.

일반적인 상용 `DBMS`는 쓰기 작업을 `버퍼링`해서 `일괄 처리`하는 기능이 대부분 탑재되어 있다.

`InnoDB` 역시 이러한 방식으로 처리하고 있다.

`MyISAM`은 사용자 스레드가 `쓰기 작업` 까지 함께 처리하도록 `설계` 되어있다.

`MyISAM`에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

### 🥲 메모리 할당 및 사용 구조

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3ba19fb1-5df4-411d-b750-05196953371f)

- `MySQL`에서 사용되는 `메모리 공간`은 **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 구분된다.
- `글로벌 메모리 영역`의 모든 메모리 공간은 MySQL 서버가 시작되면서 `운영체제`가 `할당`한다.

`운영체제`가 메모리를 `할당`하는 방식은 매우 복잡하고, `운영 체제`의 종류에 따라 

요청된 공간을 `100% 할당`해줄수도 있고 그 공간만큼 `예약`해두고 `조금씩 할당`해 줄 수도 있다.

`글로벌 메모리 영역`과 `로컬 메모리 영역`은 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

### 🧔🏼‍♂️ 글로벌 메모리 영역

- `클라이언트 스레드`의 수와 무관하게 `하나의 메모리 공간`만 할당된다.
- 필요에 따라 `2개 이상`의 메모리 공간을 할당받을 수 있지만 `클라이언트 스레드 수`와는 `무관`하다.
- 생성된 글로벌 영역이 `N개`라 하더라도 `모든 스레드`에 의해 `공유`된다.

대표적인 `글로벌 메모리 영역`은 아래와 같다.

- `테이블 캐시`
- InnoDB `버퍼 풀`
- InnoDB `어댑티브 해시 인덱스`
- InnoDB `리두 로그 버퍼`

### 😄 로컬 메모리 영역

- `세션 메모리 영역`이라고도 표현하며 `MySQL` 서버상에 존재하는 `클라이언트 스레드`가 쿼리를 처리하는데    사용하는 `메모리 영역`이다.
- 대표적으로 `커넥션 버퍼`와 `정렬(소트)`버퍼 등이 있다.
- `클라이언트 메모리 영역`이라고 부르기도 한다.

`로컬 메모리`는 각 `클라이언트 스레드`별로 독립적으로 할당되고 절대 `공유`되어 사용되지 않는다.

`로컬 메모리 영역`을 크게 신경 쓰지 않고 설정하는데 최악의 경우 `MySQL 서버`가 `메모리 부족`으로 멈출 수 있다.

`로컬 메모리 공간`은 각 `쿼리`의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 `MySQL`이 메모리 공간을 **할당조차도 하지 않을 수 있다.**

`소트 버퍼`나 `조인 버퍼`와 같은 공간이 특히 그렇다.

`로컬 메모리 공간`은 **커넥션이 열려 있는 동안 계속 할당된 상태**로 남아 있는 `공간`도 있고,

**쿼리를 실행하는 순간에만 할당**했다가 `다시 해제`하는 `공간`도 있다.

대표적인 `로컬 메모리 영역`은 아래와 같다.

- 정렬 버퍼(Sort buffer)
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 😑 플러그인 스토리지 엔진 모델
![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/ce107921-4d35-406a-9f8f-7e51af5c763e)


- `MySQL`의 독특한 구조 중 대표적인 것이 `플러그인 모델`이다.
- `플러그인`해서 사용할 수 있는 것이 `스토리지 엔진`만 존재하는 것은 아니다.

`MySQL`은 기본적으로 `많은 스토리지 엔진`을 가지고 있지만, 모든 사용자의 요구 조건을 만족시킬 수 없다.

따라서 `부가적인 기능`을 더 제공하는 `스토리지 엔진`은 **사용자 또는 다른 회사가 개발해서 사용한다.**

`MySQL`에서 쿼리를 실행한다면, `MySQL 엔진`에서 **거의 대부분의 작업이 처리**된다.

마지막 `데이터 읽기 & 쓰기` 작업만 **스토리지 엔진에 의해 처리**된다.

사용자가 `새로운 용도`의 `스토리지 엔진`을 만든다면, **전체 기능**이 아닌 **일부분의 기능**만 `수행`한다.
![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/46671d26-c616-4e1b-897d-d6298c170107)

데이터 읽기 & 쓰기 작업은 대부분 1건의 레코드 단위로 처리된다.

`MySQL`을 사용하다 보면 `핸들러`라는 단어가 자주 등장한다.

`핸들러`라는 단어는 `MySQL 서버`의 `소스코드`로부터 넘어온 표현이며, `MySQL 엔진`이 **스토리지 엔진**을 조정하기 위해 `핸들러`를 **사용**한다고 이해하면 쉽다.

`MySQL 서버`의 **상태 변수**라는 개념이 나오는데, `Handler_`로 시작하는 변수는 `MySQL 엔진`이

각 `스토리지 엔진`에게 보낸 **명령의 횟수**를 의미하는 `변수`라고 생각하면 된다.

`MySQL`에서 `MyISAM`이나 `InnoDB`와 같이 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행해도

`MySQL`의 **처리 내용은 대부분 동일**하다.

다만 실질적인 `GROUP BY`나 `ORDER BY` 등 복잡한 처리를 **MySQL 엔진의 쿼리 실행기가 처리**한다.

`MySQL서버(mysqld)`에서 지원되는 `스토리지 엔진`이 어떤 것이 있는지 확인하려면

아래의 명령을 실행하면 된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/f2d1702a-33b7-409b-95c8-01c8edb2466f)

조회 된 데이터 중 `Support 컬럼`에 표시될 수 있는 값은 아래와 같다.

- `YES` : MySQL 서버에 해당 스토리이 엔진이 포함되어 있고 사용가능으로 활성화된 상태
- `DEFAULT` : ‘YES’와 동일한 상태이지만 필수 스토리지 엔진이다.
- `NO` : 현재 MySQL 서버에 포함되지 않았음을 의미함
- `DISABLED` : 현재 MySQL 서버에는 포함되어 있지만 파라미터에 의해 비활성화 된 상태임

**MySQL 서버에 포함되지 않은 스토리지 엔진**을 사용하려면 `MySQL 서버`를 `다시 빌드` 해야 한다.

물론, `플러그인 형태`로 빌드된 **스토리지 엔진 라이브러리**를 다운로드해서 끼워 넣기만 하면 `사용`은 `가능`하다.

`플러그인 형태`의 스토리지 엔진은 손쉽게 업그레이드 할 수 있다는 장점이 있다.

`스토리지 엔진`뿐만 아니라 모든 플러그인의 내용은 아래의 명령어로 확인할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/4efe435e-09c6-45fd-9fcf-d2e42eeefc82)

`외부`에서 `플러그인`을 다운로드 받아 사용하는 것이 일반적이지만, 사용자가 **요구사항에 맞게 커스텀**해야 한다면,

`플러그인 API`가 매뉴얼에 공개되어 있으므로 직접 `개발`하거나 `확장`할 수 있다.

### 🌈 컴포넌트

`MySQL 8.0` 버전 부터는 기존의 플러그인 아키텍처를 `대체`하기 위해 `컴포넌트 아키텍처`를 지원한다.

`플러그인`은 아래와 같은 몇 가지 단점이 있어, `컴포넌트`가 단점을 **보완해서 구현**됐다.

- `플러그인`은 오직 **MySQL 서버**와 `인터페이스`할 수 있고, `플러그인`끼리는 통신할 수 없다.
- `플러그인`은 **MySQL 서버**의 변수나 함수를 직접 호출하기 때문에 안전하지 않다(`캡슐화` 안 됨)
- `플러그인`은 **상호 의존 관계**를 설정할 수 없어서 `초기화`가 어렵다.

`플러그인`과 마찬가지로 `컴포넌트`도 설치하면서 새로운 시스템 변수를 설정해야 할 수도 있다.

따라서 `컴포넌트`를 사용하기 전에 관련 `매뉴얼`을 살펴보는 것이 좋다.

### 🫡 쿼리 실행 구조

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/54604e8f-1fed-4ea8-8e4e-b363860ecdbb)

`쿼리`를 **실행하는 관점**에서 `MySQL`의 `구조`는 위의 그림과 같이 표현할 수 있다.

**쿼리 파서**

- `쿼리 파서`는 사용자 요청으로 들어온 쿼리 문을 토큰으로 분리해 `트리 형태`의 `구조`로 만들어낸다.
- `쿼리 문장`의 **기본 문법 오류**는 이 과정에서 발견되고 사용자게에 `오류 메시지`를 `전달`하게 된다.

**전처리기**

- `파서 과정`에서 만들어진 `파서 트리`를 기반으로 `쿼리 문장`에 **구조적인 문제점이 있는지 확인**한다.
- 각 `토큰`을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 **개체를 매핑**한다.
- 해당 객체의 `존재 여부`와 `접근 권한` 등을 `확인`하고, **존재하지 않거나 권한상 사용할 수 없는 개체의 토큰**은 이 단계에서 걸러진다.

**옵티마이저**

- `옵티마이저`란 사용자의 요청으로 들어온 `쿼리 문장`을 저렴한 비용으로 **가장 빠르게 처리할지 결정하는 역할**을 담당한다.
- `옵티마이저`의 역할은 중요하고 **영향 범위 또한 아주 넓다.**

### 😑 실행 엔진

`옵티마이저`가 **두뇌**라면 `실행 엔진`과 `핸들러`는 **손과 발**에 비유할 수 있다.

`옵티마이저`와 `실행 엔진` 그리고 `핸들러`의 관계에서 **GROUP BY**를 처리한다면 어떻게 처리할까?

`옵티마이저`가 **임시 테이블을 사용하기로 결정**했다는 가정하에 만들어진 예제다.

1. `실행 엔진`이 핸들러에게 `임시 테이블`을 만들라고 요청
2. 다시 실행 엔진은 `WHERE 절`에 일치하는 레코드를 읽어오라고 `핸들러`에게 요청
3. 읽어온 레코드들을 1번에서 준비한 `임시 테이블로 저장`하라고 다시 `핸들러`에게 요청
4. 데이터가 준비된 `임시 테이블`에서 필요한 방식으로 데이터를 읽어 오라고 `핸들러`에게 다시 요청
5. 최종적으로 `실행 엔진`은 `결과`를 **사용자나 다른 모듈로 넘김**

`실행 엔진`은 만들어진 계획대로 각 `핸들러`에게 요청해서 받은 결과를 또 다른 `핸들러` 요청의 입력으로 연결하는 

`역할`을 `수행`한다.

### 🤓 핸들러(스토리지 엔진)

- `MySQL` 서버의 `가장 밑단`에서 MySQL `실행 엔진`의 요청에 따라 **데이터를 디스크로 저장하고 읽어 오는 역할을 담당한다.**
- `핸들러`는 결국 **스토리지 엔진을 의미한다.**
- `핸들러`는 `MyISAM 테이블`을 조작하면 **MyISAM 스토리지 엔진**, `InnoDB 테이블`을 조작하면 **InnoDB 스토리지 엔진**이다.

### 😐 쿼리 캐시

- `MySQL 서버`에서 `쿼리 캐시(Query Cache)`는 **빠른 응답을 필요로 하는 응용 프로그램**에서 매우 중요한    역할을 담당했다.
- `쿼리 캐시`란 **SQL의 실행 결과**를 `메모리`에 `캐시`하고, **동일 SQL 쿼리가 실행**하면 `테이블`을 읽지 않고     `즉시`  결과를 반환하여 **성능이 매우 높았다.**

`쿼리 캐시`는 **테이블의 데이터가 변경**되면 `캐시`에 저장된 결과 중에서 `변경된 테이블`과 관련 있는 

**데이터는 모두  삭제**해야 했다.

이로 인해 심각한 `동시 처리 성능 저하`를 유발하고 `많은 버그의 원인`이 되어 왔기에 **8.0 버전부터 제거** 되었다.

`쿼리 캐시` 기능은 `데이터 변경`이 거의 없고 읽기만 하는 서비스에서는 `큰 효율`을 주겠지만,

대부분 실제 큰 도움이 되지 않고 `버그`만 유발하기에 `삭제` 한 것은 좋은 선택이다.

### 🤑 스레드 풀

- 내장 `스레드 풀` 기능은 **MySQL 엔터프라이즈 에디션**만 지원한다.
- **MySQL 커뮤니티 버전**은 `Percona Server`에서 제공하는 `스레드 풀` 기능을 `사용`할 수 있다.

`MySQL 엔터프라이즈` 스레드 풀 기능은 **MySQL 서버 프로그램에 내장**되어 있지만,

`Percona Server` 스레드 풀은 **플러그인 형태로 작동하게 구현**되어 있다.

`스레드 풀`은 내부적으로 **사용자의 요청을 처리하는 스레드 개수**를 줄여서 `동시 처리`되는 `요청`이 많아도,

`CPU`가 **제한된 개수의 스레드 처리에만 집중**할 수 있게 해서 `서버`의 `자원 소모`를 줄이는 것이 `목적`이다.

`스레드 풀`을 설치한다고 해서 `드라마틱`하게 `성능`이 향상되지 않는다.

`스레드 풀`이 `실제 서비스`에서 **눈에 띄는 성능 향상을 보여준 경우는 극히 드물다.**

심지어 `스케줄링 과정`에서 `CPU 시간`을 제대로 확보하지 못한다면 **쿼리 처리가 더 느려질 수도 있다.**

`제한된 수의 스레드`만으로 **CPU가 처리하도록 적절히 유도**하면 `불필요한 컨텍스트 스위치 비용`도 낮추는

장점도 얻을 수 있다.

`Percona Server`의 `스레드 풀`은 기본적으로 **CPU 코어의 개수만큼 스레드 그룹을 생성**한다.

`스레드 그룹`의 개수는 **thread_pool_size 시스템 변수를 변경해서 조정**할 수 있다.

`일반적`으로는 **CPU 코어의 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는 데 좋다.**

`MySQL 서버`가 처리해야 할 요청이 생기면 `스레드 풀`로 처리를 이관하는데, 이미 `스레드 풀`이 처리 중인

작업이 있는 경우 `thread_pool_oversubscribe`에 **설정된 개수만큼 추가로 더 받아들인다.**

이 값이 너무 크면 `스케줄링`해야 할 `스레드`가 많아져서 **스레드 풀이 비효율적으로 작동할 수도 있다.**

`스레드 그룹`의 모든 `스레드`가 일을 처리하고 있다면, `스레드 풀`은 해당 스레드 그룹에 `새로운 작업 스레드`를

추가할 지, **기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부**를 `판단`해야 한다.

`스레드 풀`의 `타이머 스레드`는 **주기적으로 스레드 그룹의 상태를 체크**해서 `thread_pool_stall_limit` 

시스템 변수에 정의된 밀리초만큼 **작업 스레드가 현재 작업을 끝내지 못하면 새로운 스레드를 생성**해서

`스레드 그룹`에 `추가`한다.

전체 `스레드 풀`에 있는 `스레드의 개수`는 **thread_pool_max_threads 값을 넘어설 수 없다.**

모든 `스레드 그룹`의 스레드가 **각자 작업을 처리하고 있는 상태**에서 `새로운 쿼리 요청`이 들어올 경우,

스레드 풀은 `thread_pool_stall_limit` 시간 동안 기다려야 **새로운 요청 처리가 가능하다.**

`응답 시간`에 아주 민감한 서비스라면 `thread_pool_stall_limit` 값을 적절히 낮춰서 설정해야 하는데,

`thread_pool_stall_limit`을 **0에 가까운 값으로 설정하는 것은 권장하지 않는다.**

`thread_pool_stall_limit`을 **0에 가까운 값**으로 설정해야 한다면 `스레드 풀`을 **안쓰는 것이 나을 정도다.**

`Percona Server`의 스레드 풀 플러그인은 `선순위 큐`와 `후순위 큐`를 이용해 

특정 `트랜잭션`이나 `쿼리`를 우선적으로 처리할 수 있는 기능도 제공하고 있다.

`먼저 시작된 트랜잭션` 내에 속한 **SQL을 빨리 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제**되고

`잠금 경합`을 낮춰서 **전체적인 처리 성능을 향상**시킬 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/e521a734-4c79-406e-b2fc-3192dd3368ee)

### 😐 트랜잭션 지원 메타데이터

- `데이터베이스 서버`에서 테이블의 `구조 정보`, `스토어드 프로그램` 등의 정보를 `데이터 딕셔너리` 또는 **메타데이터**라고 한다.
- `MySQL 5.7` 버전까지는 `테이블의 구조`를 **FRM 파일에 저장**하고 일부 `스토어드 프로그램`도 **파일 기반으로 관리했다.**

`파일 기반`의 **메타데이터**는 생성 및 변경 작업이 `트랜잭션`을 **지원하지 않는다는 문제점**이 있다.

`테이블`의 **생성**이나 **변경** 도중 `서버`가 **비정상적으로 종료**되면 `일관되지 않은 데이터`가 남게된다.

`MySQL 8.0` 버전부터는 **테이블**의 `구조 정보`나 **스토어드 프로그램**의 `코드 관련 정보`를 `InnoDB`의 

테이블에 저장하도록 개선하고, `InnoDB` **스토리지 엔진**을 `사용`하도록 했다..

`MySQL 서버`가 작동하는데 `기본적`으로 필요한 `테이블`들을 묶어서 **시스템 테이블**이라고 부르는데,

대표적으로 `사용자의 인증` 또는 `권한`에 관련된 `테이블`들이 있다.

`시스템 테이블`과 `데이터 딕셔너리` 정보를 모두 모아서 **mysql DB**에 저장하고, 이 데이터들은 통째로

`mysql.ibd`라는 파일로 저장된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3645f4ca-f276-46e3-880c-f52d2495f726)

`8.0` 버전부터 서버가 비정상적으로 종료된다고 하더라도 `스키마 변경`이 **완전한 성공 또는 실패**로 `정리`된다.

그렇다면 `MyISAM`이나 `CSV`와 같은 다른 **스토리지 엔진**들은 어떨까?

`MySQL 서버`는 **InnoDB 스토리지 엔진** 이외의 스토리지 엔진을 사용하는 테이블들은 **SDI 파일**을 사용하게 한다.

기존의 `FRM 파일`과 동일한 역할을 하며, `InnoDB 테이블`의 구조도 `SDI 파일`로 `변환`이 가능하다.

`ibd2sdi` 유틸리티를 사용하면 `InnoDB 테이블 스페이스`에서 **스키마 정보를 추출**할 수 있다.

추출한 스키마를 `JSON 파일`로 `덤프`해서 확인할 수도 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/2bf1cef1-82f8-48fe-aa9f-5a3680c16e5f)

### 🙂 InnoDB 스토리지 엔진 아키텍처

- `InnoDB`는 **MySQL**에서 사용할 수 있는 `스토리지 엔진` 중 **거의 유일하게 레코드 기반의 잠금**을 `제공`한다.
- `높은 동시성 처리`가 가능하고 **안정적이며 성능이 뛰어나다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/31c968cf-723c-422c-a79d-b3808c53fa38)

**프라이머리 키에 의한 클러스터링**

- `InnoDB`의 모든 테이블은 기본적으로 `프라이머리 키`를 기준으로 **클러스터링되어 저장된다.**
- 모든 `세컨더리 인덱스`는 레코드의 주소 대신 `프라이머리 키의 값`을 **논리적인 주소로 사용**한다.

`클러스터링 인덱스`의 `레인지 스캔`은 상당히 빨리 처리될 수 있으므로, `쿼리의 실행 계획`에서 `프라이머리 키`는

기본적으로 다른 `보조 인덱스`보다 **비중이 높게 설정**되어 있다.

`오라클 DBMS`의 **IOT(Index organized table)**와 동일한 구조가 `InnoDB`에서는 

**일반적인 테이블의 구조**가 된다.

`MyISAM` 스토리지 엔진은 `클러스터링 키`를 **지원하지 않는다.**

따라서 `MyISAM` 테이블에서는 `프라이머리 키`와 `세컨더리 인덱스`는 **구조적으로 차이가 없다.**

`MyISAM` 테이블의 `프라이머리 키`를 포함한 `모든 인덱스`는 **물리적인 레코드의 주소 값(ROWID)**를 가진다.

**외래 키 지원**

- `외래 키`에 대한 지원은 `InnoDB 스토리지` **엔진 레벨에서 지원하는 기능**이다.
- `MyISAM`이나 `MEMORY` 테이블에서는 사용할 수 없는 기능이다.

`외래 키`를 **데이터베이스 서버 운영**이 불편해서 사용하지 않는 경우가 있는데 왜 그런걸까?

`InnoDB`에서 **외래 키**는 `부모 테이블`과 `자식 테이블` 모두 **해당 컬럼에 인덱스 생성**이 필요하다.

`데이터 변경` 시에는 **부모 테이블**이나 **자식 테이블**에 `데이터`가 있는지 `체크하는 작업`이 필요한데, 이 작업은

`여러 테이블`에 `잠금`을 `전파`할 수 있으므로 `데드락`이 발생할 수 있다.

`수동`으로 `데이터`를 적재하거나 `스키마 변경` 등의 **관리 작업**에도 `실패`할 수 있다.

한 번 `작업`이 꼬이기 시작하면 `외래 키`가 `복잡`하게 얽힌 경우에는 `간단`하게 `해결`하기가 어렵다.

이럴때는 `외래 키` 관계에 대한 `체크 작업`을 멈추게 할 수 있는데 `foreign_key_checks` 시스템 변수의 값을

`OFF`로 `설정`하면 된다.

```sql
mysql> SET foreign_key_checks=OFF;

// 작업 실행

mysql> SET foreign_key_checks=ON;
```

`외래 키` 체크를 해제했다고 해서, **부모 자식 테이블**의 `관계`를 **깨진 상태로 놓아도 된다는 것이 아니다.**

`외래 키 관계`를 가진 **부모 테이블**의 `레코드`를 **삭제**했다면 `자식 테이블`의 **레코드**도 

`삭제`해서 **일관성을 유지**해야 한다.

`일관성`을 전부 맞췄다면, `외래 키 체크 기능`을 **활성화**해야 한다.

`foreign_key_checks`가 비활성화되면 **외래 키 관계**의 `부모 테이블`에 대한 **작업도 무시**되기 때문이다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/63b2be60-d1c4-439c-988d-c2a92c8bba15)

### 😚 MVCC(Multi Version Concurrency Control)

- `레코드 레벨`의 **트랜잭션**을 지원하는 `DBMS`는 **MVCC**를 제공한다.
- `MVCC`의 목적은 **잠금**을 사용하지 않는 `일관된 읽기`를 **제공**하는 것이다.
- `InnoDB`는 이 기능을 **언두 로그(Undo Log)**를 이용해 `구현`하고 있다.

`멀티 버전`이란 **하나의 레코드**에 대해 `여러 개의 버전`이 `동시`에 `관리`되고 있다는 의미다.

격리 수준이 `READ_COMMITED`인 경우 테이블의 **데이터 변경**을 어떻게 처리하는지 아래의 그림으로 

이해해 볼 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3c39c4e2-cffe-41f1-a55c-e5bec94cc010)

위의 `쿼리`를 실행하면 `InnoDB 엔진`은 아래와 같이 처리한다.

- `INSERT` 문 실행시의 그림

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/bee14f44-9f51-40fa-8e69-e240ff75011f)

- `UPDATE` 문 실행시의 그림

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/a19e6d8c-1c01-4e1d-9557-8527dbcb3fa7)

`UPDATE` 문장이 실행되면 `커밋 실행` 여부와 관계없이 **InnoDB 버퍼 풀**은 새로운 값인 ‘경기’로 업데이트 된다.

`디스크`의 데이터 파일에는 `체크포인트`나 `InnoDB`의 **Write 스레드**에 의해 새로운 값으로 

`업데이트` 될 수도 있고 아닐 수도 있다.

그렇다면, 아직 `COMMIT`이나 `ROLLBACK` 되지 않은 상태에서 **사용자가 조회를 시도**하면 어떻게 될까?

`MySQL` 서버의 시스템 변수 `transaction_isolation`에 설정된 `격리 수준`에 따라 다르다.

- `READ_UNCOMMITED`

`InnoDB 버퍼 풀`이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.

데이터의 `커밋 여부`와 상관없이 **변경된 상태의 데이터**를 `반환`하는 것이다.

- `그 이상의 격리 수준`

`READ_UNCOMMITED` 이상의 격리 수준인 `READ_COMMITED`나 `REPEATABLE_READ`,

`SERIALIZABLE`인 경우에는 **언두 영역의 데이터를 반환**한다.

즉 `MVCC`는 하나의 레코드에 대해 `2개 버전`이 유지되고, 필요에 따라 어떤 `데이터`가 보여지는지

**상황에 따라 달라지는 구조**를 가지고 있다.

물론, 예제는 `한 개의 데이터`만 가지고 설명하고 있지만 `예전 버전의 데이터`는 **무한히 많아질 수 있다.**

`COMMIT` 명령이 수행되면, `InnoDB`는 더 이상 변경 작업 없이 현재 상태를 `영구히 반영`한다.

`ROLLBACK` 명령이 수행되는 경우, `언두 영역`에 있는 `백업 데이터`를 **InnoDB 버퍼 풀로 다시 복구**하고,

**언두 영역의 내용을 삭제**한다.

### 🤪 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- 격리 수준이 `SERIALIZABLE`이 아니라면, `INSERT`와 연결되지 않는 **순수한 읽기 작업**은 `잠금 대기` 없이 바로 실행된다.
- `특정 사용자`가 `레코드`를 변경하고 아직 `커밋`을 수행하지 않아도, **변경 트랜잭션**은 다른 사용자의 조회 작업을 방해하지 않는다.
- 이를 `잠금 없는 일관된 읽기` 라고 `표현`한다.
- `InnoDB`에서는 변경되기 전의 데이터를 읽기 위해 `언두 로그`를 사용한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/ca316d5e-683c-4e07-8cd5-82a1a2ee4082)

`오랜 시간` 동안 **활성 상태인 트랜잭션**으로 인해 `MySQL` 서버가 느려지거나 `문제`가 `발생`하는 경우가 있다.

따라서 `트랜잭션`이 시작되었다면 가능하면 `롤백`이나 `커밋`을 빨리해서 `트랜잭션`을 끝내야 한다.

### 😏 자동 데드락 감지

- `InnoDB` 스토리지 엔진은 내부적으로 잠금이 `교착 상태`에 빠지지 않았는지 `체크`한다.
- `잠금 대기 목록`은 **그래프(Wait-for List) 형태로 관리**한다.
- `InnoDB` 스토리지 엔진은 **데드락 감지 스레드**를 활용해 `데드락`을 **주기적으로 감지**한다.

`데드락 감지 스레드`는 **잠금 대기 그래프**를 주기적으로 검사하여 `교착 상태`에 빠진 `트랜잭션`들 중 하나를

`강제 종료` 시킨다.

`강제 종료`시킬 `트랜잭션`을 선정하는 기준은, `트랜잭션`이 현재 보유한 `언두 로그 양`으로 판단하며

`언두 로그`가 적은 `트랜잭션`이 종료된다.

`InnoDB` 스토리지 엔진은 상위 레이어인 `MySQL 엔진`에서 관리되는 `테이블 잠금`을 볼 수 없어서

`데드락 감지`가 불확실할 수 있는데, `innodb_table_locks` 시스템 변수를 활성화 하면 `문제`가 `해결`된다.

`InnoDB` 스토리지 엔진 내부의 `레코드 잠금`과 `테이블 레벨`의 `잠금`까지 감지할 수 있게 된다.

물론 `자동 데드락 감지` 기능에도 주의해야 할 점도 있다.

`동시 처리 스레드`가 매우 많아지거나 각 `트랜잭션`이 가진 **잠금의 개수가 많아지는 경우**에는 

`데드락 감지 스레드`가 느려진다.

`잠금 목록`을 검사해야 하기 때문에 `잠금 상태`가 변경되지 않도록 `잠금 목록`이 저장된 리스트에 `새로운 잠금`을

걸고, `데드락 스레드`를 찾기 때문이다.

`데드락 감지 스레드`가 느려지면 **서비스 쿼리**를 처리 중인 `스레드`는 **작업을 진행하지 못하고 대기**하면서 서비스에

`악영향`을 미치게 된다.

`MySQL 서버`는 이 문제를 해결하기 위해서 `innodb_deadlock_detect` 시스템 변수를 제공한다.

이 시스템 변수를 `OFF`로 설정하면 `데드락 감지 스레드`는 더 이상 작동하지 않는다.

이로 인해 `InnoDB` 스토리지 엔진 내부에서 **2개 이상의 트랜잭션**이 

**상대방이 가진 잠금을 요구하는 상황**이 발생해도 `무한정 대기`하는 상황이 오게 된다.

따라서 이런 문제를 방지하려면 `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 된다.

`변수`를 `활성화`하면 **일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환**하게 된다.

`데드락 감지 스레드`가 부담되어 `OFF` 하는 경우, `innodb_lock_wait_timeout`을 기본값인 `50초`보다

훨씬 `낮은 시간`으로 `변경`해서 `사용`하는 것이 좋다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/fbbb6ff7-7875-4226-a800-71306162cf84)

### 😏 자동화된 장애 복구

- `InnoDB`에는 손실이나 장애로부터 `데이터`를 `보호`하기 위한 **여러 가지 메커니즘이 탑재**되어 있다.
- `MySQL 서버`가 시작될 때 **완료되지 못한 일련의 복구 작업이 자동으로 진행**된다.

`InnoDB` 스토리지 엔진은 견고하기 때문에 `데이터 파일`이 `손상`되거나 MySQL 서버가 시작되지 못하는

경우는 **거의 발생하지 않는다.**

`MySQL 서버`와 무관하게 `디스크`나 `서버 하드웨어 이슈`로 InnoDB 스토리지 엔진이 자동으로 복구하지 못하는

경우가 발생할 수 있는데, **이 문제는 복구하기가 쉽지 않다.**

`MySQL 서버`가 시작될 때 항상 `InnoDB 데이터 파일`은 **자동 복구**를 수행하는데, 이 단계에서 자동 복구가 안 될

정도의 손상이 있다면 `자동 복구`를 멈추고 **MySQL 서버가 종료된다.**

이런 상황이 발생하면, `MySQL 서버`의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 

서버를 시작해야 한다.

이 설정 값은 `InnoDB` 스토리지 엔진이 `데이터 파일`이나 

`로그 파일`의 **손상 여부 검사 과정을 선별적으로 진행**할 수 있도록 도와준다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/a92ee32b-2085-4b2c-874f-f2b7f02f4113)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/0b5ba761-19e9-4618-86f7-20418b5e67bf)

`innodb_force_recovery`의 값이 커질수록 심각한 상황이고, 데이터 손실 가능성이 커진다.

`MySQL 서버`가 기동되고 `InnoDB 테이블`이 인식된다면 `mysqldump`를 이용해 **데이터를 가능한 만큼 백업**하고

서버의 `DB`와 `테이블`을 **다시 생성하는 것이 좋다.**

`InnoDB`의 복구를 위해 `innodb_force_recovery` 옵션에 설정 가능한 값은 `1~6`까지 있다.

이 값이 `0`이 아닌 복구 모드에서는 `SELECT` 이외의 **쿼리는 모두 수행할 수 없다.**

각 `숫자 값`으로 복구되는 `장애 상황`과 `해결 방법`은 아래와 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9cc22103-3215-4b8c-8922-25b593cea0e2)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/cb643a7f-96e5-4b83-9695-f65f54c069cc)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/04ddd179-9146-4932-a2b7-8648d1811f86)

`1~6` 까지의 값을 전부 셋팅하고 시도해도 `MySQL 서버`가 **시작되지 않는 최악의 경우가 발생**한다면,

`백업`을 이용해 **다시 서버를 구축하는 방법**밖에 없다.

`마지막 백업`으로 **데이터베이스를 새로 구축**하고, `바이너리 로그`를 사용해 **최대한 장애 시점까지의 데이터를**

**복구**할 수 있을 것이다.

마지막 `풀 백업 시점`부터 `장애 시점`까지의 **바이너리 로그**가 있다면 `InnoDB` 복구를 이용하는 것보다 **풀 백업**과

`바이너리 로그`로 복구하는 편이 `데이터 손실`이 더 적을 수 있다.

`백업`은 있지만 복제의 `바이너리 로그`가 없거나 손실됐다면 마지막 `백업 시점`까지 복구가 가능하다.
