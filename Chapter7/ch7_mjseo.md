# Chapter 7

### 🤢 MySQL 서버의 데이터 암호화

- `MySQL 5.7` 버전부터 지원된 `데이터 암호화 기능`은 처음에는 **데이터 파일에 대해서만 암호화**가 가능했다.
- `MySQL 8.0` 버전부터 `데이터 파일`과 `리두 로그`, `언두 로그`, `바이너리 로그` 등도 **암호화가 가능**해졌다.

`MySQL 서버`의 암호화 기능은 **데이터베이스 서버와 디스크 사이의 데이터를 읽고 쓰는 지점**에서

`암호화` 또는 `복호화`를 수행한다.

`MySQL 서버`에서는 `디스크 입출력` 이외의 부분에는 암호화 처리가 전혀 필요하지 않다.

따라서 `MySQL 서버`의 **I/O 레이어에서만 데이터의 암호화 및 복호화 과정이 실행**된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d0cc3804-4e0a-434f-b141-96415a88bb3c)

`MySQL 서버`에서 `사용자`의 `쿼리`를 처리할 때 테이블 데이터 암호화 여부는 식별할 필요가 없다.

`암호화 된 테이블`도 그렇지 않은 **테이블과 동일한 처리 과정**을 거치게 된다.

`데이터 암호화 기능`이 활성화 되어 있다고 하더라도 `MySQL` 내부와 사용자 입장에서는

아무런 차이가 없기 때문에 이런 `암호화 방식`을 `TDE`라고 부른다.

이런 암호화 방식을 `TDE` 또는 `Data at Rest Encryption` 이라고 부르는데,

`MySQL 메뉴얼`에서는 `TDE`라는 표현을 사용한다.

### 🤩 2단계 키 관리

- `MySQL` 서버의 `TDE`에서 암호화 키는 `KeyRing` 플러그인에 의해 관리된다.

`MySQL 8.0` 버전에서 지원되는 **키링 플러그인은 총 4가지 종류**가 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9b69dc84-2201-4981-99fb-d1edb9107ec8)

`MySQL` 커뮤니티 에디션에서는 `keyring_file` 플러그인만 사용 가능하고,

엔터프라이즈 에디션에서 나머지 플러그인이 사용 가능하다.

다양한 `플러그인`이 제공되지만 `마스터 키`를 관리하는 방법만 다르고,

`MySQL 서버` 내부적으로 **작동하는 방식은 모두 동일**하다.

`MySQL 서버`의 키링 플러그인은 `2단계 키 관리 방식`을 사용한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/7511b3df-f100-4d78-84aa-96325030913a)

`MySQL 서버`의 데이터 암호화는 `Master Key`와 `Tablespace Key`로 구성되고,

테이블스페이스 키는 `Private Key` 라고도 부른다.

MySQL 서버는 `HashiCorp Vault`와 같은 외부 키 관리 솔루션 또는 디스크의 파일에서 마스터 키를

가져오고, `암호화된 테이블`이 생성될 때마다 **임의의 테이블 스페이스 키를 발급**한다.

생성된 `마스터 키`를 이용해 **테이블스페이스 키를 암호화**해서 각 테이블의 `데이터 파일 헤더`에 `저장`한다.

`테이블스페이스 키`는 테이블이 삭제되지 않는 이상 절대 변경되지 않는다.

`테이블스페이스 키`는 MySQL 서버 외부로 노출되지 않아서, 변경할 이유가 없지만

`마스터 키`는 외부의 파일을 이용하므로 **주기적으로 변경**해야 한다.

MySQL 서버의 `마스터 키`는 아래의 명령어로 변경할 수 있다.

```sql
mysql> ALTER INSTANCE ROTATE INNODB MASTER KEY;
```

`마스터 키`를 변경하면 `MySQL 서버`는 기존의 마스터 키를 이용해 각 테이블의 테이블 스페이스 키를

복호화하고, `새로운 마스터 키`로 다시 `암호화`한다.

`마스터 키`가 변경되는 동안 MySQL 서버의 **테이블 스페이스 키 자체와 데이터 파일의 데이터는 변경되지 않는다.**

`MySQL 서버`가 2단계 암호화 방식을 사용하는 이유는 **암호화 키 변경으로 인한 시스템 부하를 피하기 위해서다.**

`MySQL 서버`의 `TDE`에서 지원되는 암호화 알고리즘은 **AES 256비트이고 다른 알고리즘은 지원되지 않는다.**

### 😛 암호화와 성능

- `TDE 방식의 암호화`는 `디스크`로부터 **한 번 읽은 데이터 페이지는 복호화 되어 버퍼 풀에 적재**된다.
- `데이터 페이지`가 **한 번 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능**을 보인다.

`쿼리`가 InnoDB 버퍼 풀에 존재하지 않는 `데이터 페이지`를 읽어야 하는 경우라면,

`복호화 과정`을 거치기 때문에 **복호화 시간 동안 쿼리 처리가 지연**된다.

`암호화된 테이블`이 변경되면 다시 **디스크로 동기화될 때 암호화**가 되어야 하기 때문에

`디스크`에 저장할 때도 추가로 시간이 더 걸릴 수 있다.

`데이터 페이지` 저장은 사용자의 쿼리를 처리하는 스레드가 아닌 `백그라운드 스레드`가 수행하기 때문에

**실제 사용자의 쿼리가 지연**되는 것은 아니다.

`조회` 작업 뿐만 아니라 `변경`이나 `삭제` 작업도 변경하려는 레코드를 `버퍼 풀`로 읽어와야 하기 떄문에

새로 읽어야 하는 `데이터 페이지`의 개수에 따라서 **복호화 지연이 발생**한다.

 `AES` 암호화 알고리즘은 암호화하고자 하는 `평문의 길이`가 짧으면 암호화 키의 크기에 따라서,

`암호화` 된 결과의 **용량이 더 커질 수 있다.**

반대로 이미 `데이터 페이지`가 `암호화 키`보다 훨씬 크다면 암호화 결과가 평문의 결과와

**동일한 크기의 암호문을 반환**한다.

따라서 `TDE`를 적용한다고 해도 `데이터 파일`의 크기는 암호화되지 않은 테이블과 동일한 

크기를 가지고, `InnoDB 버퍼 풀`의 효율이나 `메모리` 사용 효율을 해치지 않는다.

같은 `테이블`에 대해 `암호화`와 `압축`이 동시에 적용되면 MySQL 서버는 **압축을 먼저 실행**하고

암호화를 적용한다. `압축`이 `암호화`보다 먼저 실행되어야 하는 이유는 아래와 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/524b9326-f78e-4637-930e-a4957f67db1a)

`암호화` 된 테이블과 그렇지 않은 테이블의 `디스크` **읽고 쓰기에 걸리는 평균 시간**은 얼마나 차이날까?

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/65d2ff67-0772-48de-94c3-abeb76182c29)

`암호화 된 테이블`의 경우 `읽기`는 **3~5배**, `쓰기`는 **5~6배** 정도 느린 것을 확인할 수 있다.

물론 이 수치는 `밀리초 단위`이므로 체감되지 않을 수 있다.

위의 표는 `performance_schema`의 `file_summary_by_instance` 테이블에 수집된 결과를 이용해

아래의 쿼리로 조회했다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/54d89295-c50f-49a7-85aa-a14e2ef36713)

### 🤨 암호화와 복제

- `TDE`를 이용한 암호화 사용시 `마스터 키`와 `테이블스페이스 키`는 MySQL 서버의 복제를 사용해도 마스터 키와 테이블스페이스 키는 동일하지 않을 수 있다.
- `MySQL` 서버에서 기본적으로 `모든 노드`는 **각자의 마스터 키를 할당**해야 한다.

`데이터베이스 서버`의 로컬 디렉터리에 `마스터 키`를 관리하는 경우에는 `소스 서버`와 `레플리카 서버`가

**서로 다른 키**를 가질 수 밖에 없지만, `원격 키 관리 솔루션`을 사용하는 경우라도 `소스 서버`와 `레플리카 서버`는

**서로 다른 키를 마스터 키**를 가지도록 해야한다.

`소스 서버`와 `레플리카 서버`는 암호화 되기 전의 값이 동일하더라도 실제 암호화 된 데이터가

저장된 데이터 파일의 내용은 완전히 달라진다.

`복제 소스`의 `마스터 키`를 변경할 때는 아래의 명령을 사용한다.

```sql
mysql> ALTER INSTANCE ROTATE INNODB MASTER KEY
```

이 명령 자체는 `레플리카 서버`로 복제되지만 

실제 `소스 서버`의 `마스터 키` 자체가 레플리카 서버로 전달되는 것은 아니다.

`마스터 키 로테이션`을 실행하면 `소스 서버`와 `레플리카 서버`가 **각각 서로 다른 마스터키를 새로 발급** 받는다.

`MySQL 서버`의 백업에서 `TDE`의 `키링 파일`을 **백업하지 않는 경우**가 있다.

`키링 파일`을 찾지 못하면 **데이터 복구를 할 수 없는 문제**가 생길 수 있다.

물론 `보안`을 위해 `키링 파일`을 **데이터 파일과 별도로 보관**하는 것이 좋지만, 복구를 감안해서 백업 방식을

정하는 것이 좋다.

### 🤓 keyring_file 플러그인 설치

- `TDE`의 암호화 키 관리는 `플러그인 방식`으로 제공된다.
- MySQL Community Edition은 `keyring_file` 플러그인 사용만 가능하다.

`keyring_file` 플러그인은 `테이블스페이스 키`를 암호화하기 위한 **마스터 키를 디스크의 파일로 관리**한다.

따라서, `마스터 키`는 `평문`으로 디스크에 저장되기 때문에 `외부`에 노출되면 **암호화는 무용지물**이 된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c9f0ffef-c510-40de-821e-78065a44dff6)

`MySQL 서버`의 다른 `플러그인`과는 달리 `TDE 플러그인`의 경우 가장 빨리 초기화되어야 한다.

따라서 `my.cnf` 파일의 `early-plugin-load` 시스템 변수에 **라이브러리를 명시**해야 한다.

`keyring_file` 플러그인이 마스터 키를 저장할 키링 파일의 경로를 `keyring_file_data` 설정에

명시하고, `keyring_file_data`의 설정 경로는 **오직 하나의 MySQL 서버만 참조**해야 한다.

하나의 `리눅스 서버`에 MySQL 서버가 2개 이상 실행중이라면 각 서버가 `서로 다른 키링 파일`을 `사용`해야 한다.

```sql
early-plugin-load = keyring_file.so
keyring_file_data = /very/secure/directory/tde_master.key
```

`MySQL 서버`의 설정 파일이 준비되면 MySQL 서버를 재시작하면 자동으로 `keyring_file` 플러그인이

초기화되고, `keyring_file` 플러그인의 초기화 여부는 `SHOW_PLUGINS` 명령으로 확인할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/6cd22232-70d8-43c3-9ed6-4e0d2493061b)

`keyring_file` 플러그인이 초기화되면 MySQL 서버는 **플러그인의 초기화**와 동시에,

`keyring_file_data` 시스템 변수의 경로에 빈 파일을 생성한다.

`플러그인`만 초기화된 상태일 뿐, 아직 `마스터 키`를 사용한 적이 없으므로 **키링 파일의 내용은 비어있다.**

`데이터 암호화` 기능을 사용하는 **테이블을 생성**하거나 

`마스터 로테이션`을 실행할때 **키링 파일의 마스터 키가 초기화**된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/78a8032a-442c-44f7-8f9c-b18be8910951)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/53b977ac-612f-4ce7-aa77-421fcbcd3e1f)

`ALTER INSTANCE ROTATE INNODB MASTER KEY` 명령을 실행하고 `바이너리 로그`의 내용을 살펴보면

아래의 사진과 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/a2bab2a3-9d15-4272-93a5-e91decbb597f)

**ALTER INSTANCE ROTATE INNODB MASTER KEY** 이벤트는 `Event_type`이 `Query`다.

`마스터 키 로테이션`을 실행하면 `SQL 문장`이 **레플리카 서버로 전달**되며, 새로 생성된 마스터 키의 값이 

`바이너리 로그`로 전달되지 않는다는 것을 의미한다.

### 😑 테이블 암호화

- `키링 플러그인`은 **마스터 키를 생성하고 관리**하는 부분까지만 담당한다.
- 어떤 `키링 플러그인`을 사용하던 관계없이 **암호화된 테이블을 생성**하고 활용하는 방법은 모두 동일하다.

`TDE`를 이용하는 `테이블`은 아래와 같이 생성할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/328f0b54-0fc9-4de1-87a7-1451a0ae39d7)

`TDE`를 이용하는 `테이블`을 생성하려면 테이블 생성 구문은 **일반적인 테이블 생성 구문과 동일**하며,

`ENCRYPTION=’Y’` 옵션만 마지막에 추가로 넣어주면 된다.

이렇게 생성된 테이블은 `데이터`가 기록될 때는 **자동으로 암호화**되고, `메모리`로 **읽어올 때는 복호화** 된다.

`TDE`를 이용하는 `테이블`에 데이터를 하나 넣고, 조회해보면 결과는 아래와 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/100ccbb7-f7f8-4393-8275-2585f52bda5d)

`MySQL` 서버에서 암호화 된 테이블을 검색하고 싶을때는 `information_schema`의

`TABLES 뷰`를 이용하면 된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/5f78ae65-cac6-4fde-ac62-8ac7f3bdb4d0)

이 `쿼리`를 응용하면 `암호화`가 적용된 `테이블`을 조회하거나 그 `갯수`를 셀 수 있다.

- `TDE`가 적용된 테이블 목록 조회

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c5430ed5-09d1-469b-b14c-a5d6831fe175)

- `TDE`가 적용된 테이블 개수 조회

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/8ff390c8-0d1c-4e7b-8ee1-42bf9135c23c)

`테이블`을 생성할 때마다 `암호화 옵션`을 주게 되면 누락할 가능성이 높다.

`default_table_encryption` 시스템 변수를 `ON`으로 설정하면 **암호화된 테이블로 생성**된다.

### 😏 응용 프로그램 암호화와의 비교

- `응용 프로그램`에서 직접 암호화해서 MySQL 서버에 저장하는 경우, `MySQL 서버`는 암호화 여부를 인지하지 못한다.
- `응용 프로그램`에서 암호화된 `컬럼`은 인덱스를 `생성`하더라도 인덱스의 기능을 100% 활용할 수 없다

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/59d598da-4733-4ee9-8ca6-e4b98f81325e)

예를 들어 위와 `같은 테이블`을 `생성`했다고 했을때,

`app_user` 테이블은 암호화되어 있지 않고 `enc_birth_year` 컬럼은 **응용 프로그램에서 이미 암호화**했다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/76ddf3f5-6a97-4c97-8e21-488e6557faa0)

`첫 번째 쿼리`와 같이, **동일 값만 검색하는 쿼리**에서는 문제가 생기지 않고 정상 검색된다.

하지만 `출생 연도 범위`로 **사용자를 검색**하거나 `출생 연도`를 **기준으로 정렬**해서 

`상위 10`개의 데이터만 조회하는 등 `동일 값`을 이용하는 `쿼리` 이외에는 대부분 제약이 있다.

`응용 프로그램`에서 직접 암호화하지 않고 `TDE`를 사용했다면,

`인덱스` 관련된 작업을 모두 처리한 후 `최종 디스크`에 데이터 **페이지를 저장할 때만 암호화**했을 것이다.

`응용 프로그램`의 암호화와 `MySQL` 서버의 암호화 기능 중 선택해야 하는 상황이라면

`MySQL` 서버의 **암호화 기능을 선택**하는 것이 좋다.

`MySQL` 서버의 `TDE` 기능을 사용하면 `MySQL` 서버에 접근만 가능하다면 **평문 데이터**를 볼 수 있다.

하지만 `응용 프로그램 암호화`의 경우 MySQL 서버에 접근할 수 있어도 **평문 데이터**를 볼 수 없다.

`응용 프로그램`에서의 암호화 기능은 **서비스의 요건과 성능을 고려해서 선택**해야 하고,

`MySQL 서버`의 암호화 기능과 혼합해서 사용하면 **안전한 서비스를 구축하는 데 도움**이 될 것이다.

### 😲 테이블스페이스 이동

- `테이블`을 다른 서버로 복사해야 하는 경우나 `특정 테이블`의 데이터 파일만 `백업`했다가 `복구`하는 경우라면 `테이블 스페이스` 이동 기능이 **레코드를 덤프했다가 복구하는 방식**보다 훨씬 빠르다.
- `TDE`가 적용되어 암호화된 테이블의 경우 `원본 서버`와 `목적지 서버`의 암호화 키가 다르기 때문에 하나 더 신경써야 할 부분이 있다.

`테이블스페이스`를 `익스포트(EXPORT)` 하려면 아래의 명령으로 할 수 있다.

```sql
mysql> FLUSH TABLES source_table FOR EXPORT;
```

이 명령이 실행되면 `MySQL` 서버는 `source_table`의 **저장되지 않은 변경 사항을 모두 디스크로 기록**하고,

`source_table`에 더 이상 접근할 수 없도록 잠금을 건다.

`source_table`의 구조를 `source_table.cfg` 파일로 기록해두고,

`source_table.ibd` 파일과 `source_table.cfg` 파일을 목적지 서버로 복사한다.

복사가 완료되면 `UNLOCK TABLES` 명령을 실행해서 `source_table`을 사용할 수 있도록 하면 된다.

이 과정은 `암호화` 되지 않은 테이블의 테이블스페이스 복사 과정을 설명한 내용이다.

`TDE`로 암호화 된 테이블에 대해서 `테이블스페이스` EXPORT 명령을 하면

`MySQL` 서버는 임시로 사용할 `마스터 키`를 발급해서 **source_table.cfp 파일로 기록**한다.

암호화 된 `테이블스페이스 키`를 **기존 마스터 키로 복호화** 하고,

임시로 발급한 `마스터 키`를 이용해 다시 암호화해서 `데이터 파일`의 **헤더 부분에 저장**해둔다.

`암호화` 된 테이블의 경우 `테이블스페이스` 이동 기능을 사용할 때는 반드시 데이터 파일과 

임시 마스터 키가 저장된 `*.cfp` 파일을 함께 복사해야 한다.

`*.cfg` 파일은 단순히 테이블의 구조만 가지고 있기 때문에 `파일`이 없어져도 `경고`만 발생하고

`테이블스페이스` 복구가 가능하지만 `*.cfp` 파일이 없어지면 **복구가 불가능**하다.

### 🙃 언두 로그 및 리두 로그 암호화

- `테이블 암호화`를 적용해도 `데이터 파일` 이외의 **디스크 파일로 기록되는 경우에는 평문으로 저장**된다.
- `테이블 암호화`를 적용해도 **리두 로그나 언두 로그, 바이너리 로그에는 평문으로 저장**된다.

`MySQL 8.0.16` 버전부터는 `innodb_undo_log_encrypt` 시스템 변수와 `innodb_redo_log_encrypt`

`시스템 변수`를 이용해 **리두 로그와 언두 로그를 암호화 된 상태로 저장**할 수 있게 되었다.

실행중인 `MySQL 서버`에서 **언두 로그나 리두 로그를 활성화**한다고 하더라도 모든 리두 로그나 언두 로그의

`데이터`를 해당 시점에 **한 번에 암호화해서 다시 저장**할 수 없다.

`MySQL 서버`는 암호화가 활성화되면 그때부터 생성되는 **리두 로그나 언두 로그만 암호화해서 저장**한다.

반대로 `암호화`가 비활성화 되면 그때부터 생성되는 **리두 로그나 언두 로그는 평문으로 저장**한다.

리두 로그와 언두 로그는 암호화를 `비활성화`한다고 해서 즉시 암호화에 사용된 키가 필요 없어지는 것은 아니다.

특히 `언두 로그`는 여전히 암호화 된 것이 있을 수 있기 때문에 **며칠 또는 몇 달 동안 암호화 키가 필요**할 수 있다.

`리두 로그`와 `언두 로그` 데이터 모두 각각의 **테이블스페이스 키로 암호화** 되고,

`테이블스페이스 키`는 다시 **마스터 키로 암호화**된다.

`ALTER INSTANCE ROTATE INNODB MASTER KEY` 명령이 실행되면,

새로운 `마스터 키`가 `발급`되고 테이블 암호화에 사용된 테이블스페이스 키와 동일하게 새로운 마스터 키에 의해

암호화된다.

`리두 로그`와 `언두 로그` 파일을 위한 프라이빗 키가 존재하고, **프라이빗 키는 마스터 키로 암호화**되어 

리두 로그 파일과 언두 로그 파일의 `헤더`에 `저장`된다.

`리두 로그`가 암호화 되었는지 확인하려면 **시스템 변수로 확인**할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c0744d7e-3383-48d4-9a61-5cd9b2d9f2d8)

`리두 로그 암호화` 설정전에 데이터를 저장하는 것과,

`리두 로그를 암호화` 설정후에 데이터를 저장하는 것이 어떻게 다른지 살펴보면 아래와 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/b6302610-61a3-4545-a9d9-d249b3a10cd5)

`INSERT` 된 레코드의 문자열이 `InnoDB`의 리두 로그에 보이는지 `grep` 명령어로 확인해보면,

`암호화` 하기 전에 `INSERT`된 **Real-MySQL**은 검색되지만 암호화 이후 `INSERT`된 Real-MongoDB 문자열은

검색이 되지 않는 것을 확인할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d964803d-dad5-43dd-a525-c4ccfe61bad3)

### 😚 바이너리 로그 암호화

- `테이블 암호화`가 적용돼도 **바이너리 로그는 평문을 저장**한다.
- `바이너리 로그`는 의도적으로 상당히 긴 시간 동안 보관하는 서비스도 있고, `증분 백업`을 위해 바이너리 로그를 보관하기도 하므로 **암호화는 상황에 따라 중요도가 높아질 수 있다.**

`바이너리 로그`와 `릴레이 로그` 파일 암호화 기능은 **디스크에 저장된 로그 파일에 대한 암호화만 담당**한다.

`MySQL 서버`의 **메모리 내부** 또는 **소스 서버와 레플리카 서버 간의 네트워크 구간**에서 `로그 데이터`를 

`암호화` 하고 싶다면, `복제`를 위한 계정이 **SSL을 사용하도록 설정**하면 된다.

### 🤥 바이너리 로그 암호화 키 관리

- `바이너리 로그`와 `릴레이 로그 파일` 데이터의 암호화를 위해서도 `MySQL 서버`는 **2단계 암호화 키 관리 방식**을 사용한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/b10f02e0-90ff-4c61-a31f-6a959049ba56)

`바이너리 로그`와 `릴레이 로그 파일`의 데이터는 **파일 키로 암호화해서 디스크로 저장**하고,

`파일 키`는 `바이너리 로그 암호화 키`로 암호화해서 **각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장**된다.

`바이너리 로그 암호화 키`는 테이블 암호화의 `마스터 키`와 동일한 역할을 하고, 파일 키는 바이너리 로그와 릴레이 로그 `파일 단위`로 **자동으로 생성**되며 로그 파일의 데이터 암호화에만 사용된다.

### 🙂 바이너리 로그 암호화 키 변경

- `바이너리 로그 암호화 키`는 다음과 같이 변경할 수 있다.

```sql
mysql> ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```

`바이너리 로그 암호화 키` 변경은 다음의 과정을 거친다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/dc041292-f386-4d73-89ac-1ed92a731d55)

이 절차에서 `4번 과정`이 상당히 시간이 걸릴 수 있다.

이를 완화하기 위해 `키링 파일`에서 바이너리 로그 암호화 키는 **내부적으로 버전 관리**가 이루어진다.

`ALTER INSTANCE ROTATE BINLOG MASTER KEY` 명령을 **연속으로 2번 실행**한다고 가정하면,

`키링 파일`에는 순차적인 시퀀스 번호를 가지는 **3개의 바이너리 로그 암호화 키가 존재**하게 된다.

`바이너리 로그`와 `릴레이 로그 파일`들을 최근 순서대로 **파일 키를 다시 암호화해서 저장**하는 작업을 하고,

모든 `바이너리 로그`와 `릴레이 로그 파일`의 파일 키가 **새로운 바이너리 키로 암호화되어 저장이 완료**되면

`기존 바이너리 로그 암호화 키`는 **키링 파일에서 제거**된다.

`바이너리 로그 파일`의 암호화 여부는 아래의 명령으로 확인이 가능하다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/85cf906d-5b2b-4d7c-b2f0-3fee16f69cf3)

### 👿 mysqlbinlog 도구 활용

- `MySQL 서버`에서는 `트랜잭션`의 내용을 추적하거나 `백업 복구`를 위해 암호화 된 `바이너리 로그`를 `평문`으로 `복호화` 해야 하는 경우가 많다.

`바이너리 로그 파일`이 암호화되면 **바이너리 로그 암호화 키가 없으면 복호화가 불가능**하다.

`암호화 키`는 MySQL 서버만 가지고 있기 때문에 **복호화가 불가능**하다.

`mysqlbinlog` 도구를 이용해 **암호화 된 바이너리 로그 파일의 내용**을 `SQL 문장`으로 풀어보면,

아래와 같이 `암호화 된 바이너리 로그 파일`을 **직접 열어 볼 수 없다는 에러**를 보게된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/05c09e3b-086f-432b-8e46-188a48e6e1fa)

`바이너리 로그 파일`의 내용을 볼 수 있는 방법은 **MySQL 서버를 통해 가져오는 방법이 유일**하다.

`mysqlbinlog` 도구가 MySQL 서버에 접속해서 `바이너리 로그`를 가져오는 방법이 최선이다.

아래의 명령어처럼 `--read-from-remote-server` 파라미터와 함께 **서버 접속 정보를 입력**해야 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/393fe942-3d7e-4318-a4b3-e80a9ed1003b)
