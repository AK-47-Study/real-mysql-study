# Chapter 8

### 😑 디스크 읽기 방식

- 최근에는 `하드 디스크`보다 `SSD 드라이브`가 많이 활용되지만, `데이터 저장 매체`는 여전히 컴퓨터에서 **가장 느린 부분**에 속한다.
- `데이터베이스`의 성능 튜닝은 `디스크 I/O`를 얼마나 줄이느냐가 관건이다.

### 😮 하드 디스크 드라이브와 솔리드 스테이트 드라이브(HDD vs SSD)

- `CPU`나 메모리 같은 주요 장치는 대부분 `전자식 장치`지만, `하드 디스크`는 기계식 장치이다.
- `데이터베이스 서버`에는 항상 **디스크 장치가 병목**이 된다.

`기계식 하드디스크`를 대체하기 위해서 `SSD`가 많이 출시되고 있다.

`SSD` 역시 기존 `하드 디스크`와 같은 **인터페이스(SATA or SAS)를 지원**하기 때문에

내장 디스크가 `DAS` 또는 `SAN`에 그대로 사용할 수 있다.

`SSD`는 기존 하드 디스크 드라이브에서 `데이터 저장용 원판`을 제거하고,

`플래시 메모리`를 장착했기 때문에 `디스크 원판`을 회전시킬 필요가 없어 성능이 좋다.

`플래시 메모리`는 전원이 공급되지 않아도 `데이터`가 삭제되지 않고,

`컴퓨터`의 메모리(D-Ram) 보다는 느리지만 `기계식 하드 디스크`보다는 월등히 빠르다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/eeac5254-a6f6-4e38-8ca4-811603275671)

시중에 판매되는 `SSD`는 **기존 하드 디스크보다 용량도 적고 가격이 비싼 편**이지만,

`SSD`가 훨씬 `대중화`된 상태이며 `DBMS` 용으로 사용할 서버에는 **대부분 SSD를 채택**하고 있다.

`디스크`의 헤더를 움직이지 않고 `데이터`를 읽는 `순차 I/O`의 경우에는 `SSD`가 하드 디스크보다 조금 빠르다.

하지만 `랜덤 I/O`는 `SSD`가 월등히 빠르다.

`데이터베이스 서버`에서는 `랜덤 I/O` 작업이 훨씬 많기 때문에, **SSD가 RDBMS 서버에 최적**이라고 볼 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/2768e00c-10d2-4809-8fb8-7e9cf2d8bed7)

`SSD`는 초당 `436`개의 트랜잭션을 처리했지만 `하드 디스크`는 초당 `60`개밖에 처리하지 못했다.

물론 이 결과는 환경에 따라서 어느정도 달라질 수 있다.

일반적인 `웹 서비스 환경`의 데이터베이스라고 가정한다면, **SSD가 하드 디스크보다는 훨씬 빠르다.**

### 👌🏼 랜덤 I/O와 순차 I/O

- `랜덤 I/O`는 하드 디스크의 원판을 돌려서 읽어야 할 데이터가 저장된 위치로 `디스크 헤더`를 `이동`시켜, 다음 데이터를 읽는 것을 의미한다.
- `순차 I/O` 또한 `하드 디스크`의 **원판을 돌려서 데이터의 저장 위치를 찾아야 하는 것**은 같다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/14072c7e-b634-4e70-b7aa-3fb5eace3f15)

위의 그림에서는 `순차 I/O`는 **3개의 페이지를 읽기 위해 1번 시스템 콜**을 요청했고,

`랜덤 I/O`는 **3개의 페이지를 읽기 위해서 3번 시스템 콜**을 요청했다.

`디스크`에 데이터를 쓰고 읽는 데 걸리는 시간은 `디스크 헤더`를 **움직여서 읽고 쓸 위치로 옮기는 단계**에서

`결정`되기 때문에, 위 그림에서는 `순차 I/O`가 `3배` 정도 빠르다고 볼 수 있다.

여러 번 쓰기 또는 읽기를 요청하는 `랜덤 I/O` 작업이 작업 부하가 훨씬 더 크다.

`데이터베이스`는 대부분 이런 작은 작업이 많기 때문에 `그룹 커밋`이나 `바이너리 로그 버퍼` 등의 `최적화 기능`을

**MySQL 서버가 제공**하고 있다.

`SSD`는 디스크 원판을 가지지 않지만, `랜덤 I/O`가 `순차 I/O`보다 **전체 처리량이 떨어진다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9ebf32d0-52fb-45b0-a926-7630d6a7bfb9)

`쿼리`를 `튜닝`한다고 해도 `랜덤 I/O`를 `순차 I/O`로 바꿔서 실행하는 방법은 많지 않다.

일반적인 쿼리 튜닝은 `랜덤 I/O` 자체를 **줄여주는 것이 가장 큰 목적**이라고 할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/44fd5d33-3e8b-4670-ab73-83309f97f79d)

### 😛 인덱스란?

- `인덱스`는 책의 맨 끝에 있는 **찾아보기(색인)와 같다**고 할 수 있다.
- `모든 테이블`의 데이터를 검색해서 `원하는 결과`를 가져오려면 **시간이 오래 걸리기 때문에 인덱스가 필요**하다.

`원하는 결과`를 빨리 찾기 위해서,

`컬럼 값`과 **해당 레코드가 저장된 주소**를 `키`와 `값`의 쌍으로 삼아서 `인덱스`를 만들어 두는 것이다.

`DBMS`의 인덱스는 `컬럼`의 값을 주어진 순서로 미리 `정렬`해서 `보관`해두기 때문에 **검색에 유리**하다.

`인덱스`는 `DBMS`의 **쓰기(INSERT, UPDATE, DELETE) 성능을 희생**하고,

`데이터 읽기 속도`를 **높이는 기능**이라고 할 수 있다.

`인덱스`는 저장될 때 저장되는 `컬럼`의 `값`을 이용해 항상 **정렬된 상태를 유지**하기 때문에,

`데이터`가 `저장`되거나 `변경`될 때마다 **항상 값을 정렬해야 하는 과정이 수반**된다.

`인덱스`를 추가할 때 `SELECT` 쿼리 문장의 `WHERE` 절에 사용되는 컬럼이라고 해서 무조건 인덱스를

생성하게 되면, `데이터 저장 성능`이 떨어지고 `인덱스`의 크기만 커져서 **역효과가 날 수 있다.**

따라서, `데이터`의 **저장 속도**를 어디까지 희생하고 `읽기 속도`를 **얼마나 더 빠르게** 만들 수 있는지

충분한 `가치 판단`을 통해 `결정`해야 한다.

`인덱스`는 데이터를 관리하는 방식과 `중복 값`의 `허용 여부`에 따라 **여러 가지**로 나눠 볼 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d4cced05-b56f-4ba7-90b6-4873a242de17)

`데이터 저장 방식`별로 구분할 경우 상당히 많은 분류가 가능하다.

`B-Tree`나 `Hash` 인덱스, `Fractal-Tree`, `Merge-Tree` 인덱스와 같이 **많은 종류가 있다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/7cb726a1-4295-430f-8399-b455aec611ab)

`데이터`의 `중복 허용 여부`로 구분하면, **유니크 인덱스와 유니크 하지 않은 인덱스**로 나눠 볼 수 있다.

`데이터`의 `중복 허용 여부`는 단순히 같은 값이 1개 존재하는지의 `단순한 차이`다.

하지만 `옵티마이저`에게는 상당히 중요한 문제다.

`유니크 인덱스`에 대해서 `동등 조건`으로 검색한다는 것은 **항상 1건의 레코드만 찾으면 된다는 뜻**이다.

`인덱스`를 기능별로 구분하면 `전문 검색용 인덱스`나, `공간 검색용 인덱스` 등이 있겠지만

`MySQL`을 사용할 때는 대부분 이 **두 가지로 해결**할 수 있다.

### 😾 B-Tree 인덱스

- `인덱싱 알고리즘` 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 `알고리즘`이다.
- 일반적으로 `B+ Tree` 또는 `B* Tree`가 사용된다.

`B-Tree`는 컬럼의 `원래 값`을 변형시키지 않고, `인덱스` 구조체 내에서 **항상 정렬된 상태를 유지**한다.

`전문 검색`과 같은 `특수한 요건`이 아니라면 **대부분 인덱스는 B-Tree 인덱스를 사용**한다.

### 🙃 B-Tree 인덱스의 구조 및 특성

- `B-Tree`는 `루트 노드`가 존재하고, 그 하위에 `자식 노드`가 붙어있는 형태다.
- `트리 구조`의 **가장 하위에 있는 노드**는 `리프 노드`, `트리 구조`에서 **루트 노드도 아니고 리프 노드도 아닌 중간 노드**들을 `브랜치 노드`라고 부른다.

`인덱스`의 `리프 노드`는 항상 실제 `데이터 레코드`를 찾아가기 위한 `주소값`을 가지고 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d49a11c6-0e66-4ce6-9010-3c271d2839ae)

`인덱스`의 **키 값은 모두 정렬**되어 있지만, `데이터 파일`의 `레코드`는 정렬되어 있지 않다.

`레코드`가 삭제되어 `빈 공간`이 생기면 그 다음의 `INSERT`는 가능하면 **삭제된 공간을 재활용**하도록

`DBMS`가 `설계`되기 때문에 항상 `INSERT` 된 순서로 `저장`되지는 않는다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/2a44d76e-567d-42a4-9dc7-e36c30ad98d9)

`인덱스`는 테이블의 키 컬럼만 가지고 있으므로 나머지 `컬럼`을 읽으려면 

`데이터 파일`에서 해당 레코드를 찾아야 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/fc864ae1-d323-40b8-b076-156af77e9b1e)

`MyISAM` 테이블의 레코드 주소는 `MyISAM` 테이블의 생성 옵션에 따라서,

레코드가 테이블에 `INSERT`된 순번이거나 **데이터 파일 내의 위치**다.

`InnoDB 테이블`에서는 `Primary Key`가 `ROWID` 역할을 한다.

두 스토리지 엔진의 인덱스의 차이점은 `세컨더리 인덱스`를 통해 **데이터 파일의 레코드를 찾아가는 방법**에 있다.

`MyISAM 테이블`은 **세컨더리 인덱스가 물리적인 주소**를 가지는 반면,

`InnoDB 테이블`은 `프라이머리 키`를 **주소처럼 사용하기 때문에 논리적인 주소**를 가진다고 볼 수 있다.

`InnoDB 테이블`에서 인덱스를 통해 `데이터`를 읽을 때는 **데이터 파일을 바로 찾아갈 수 없다.**

`인덱스`에 저장되어 있는 `프라이머리 키 값`을 이용해서 **프라이머리 키 인덱스를 한 번 더 검색**하고,

`프라이머리 키 인덱스`의 **리프 페이지에 저장되어 있는 레코드를 읽는다.**

이 작업으로 인해서 `InnoDB 스토리지 엔진`을 사용하는 `테이블`은 `성능`이 떨어질 것 같이 보이지만,

`MyISAM` 인덱스 구조와 `InnoDB` 인덱스 구조는 **각자의 장단점이 있다.**

### 🫠 B-Tree 인덱스 키 추가 및 삭제

- `테이블`의 `레코드`를 저장하거나 변경하는 경우 **인덱스 키 추가나 삭제 작업이 발생**한다.
- `인덱스 키` 추가나 삭제가 어떻게 처리되는 지 알면 **쿼리의 성능을 쉽게 예측**할 수 있다.

### 🤩 인덱스 키 추가

- 새로운 키 값이 `B-Tree`에 저장될 때 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.
- `B-Tree`에 저장될 때는 저장될 키 값을 이용해 `저장`될 `적절한 위치`를 `검색`해야 한다.

`리프 노드`가 꽉 차서 더는 저장할 수 없을 때는 `리프 노드`가 `분리`되어야 하는데, 

이렇게 되면 `상위 브랜치 노드`까지 처리의 범위가 넓어지므로, **상대적으로 쓰기 작업에 비용이 많이든다.**

`MyISAM`이나 `MEMORY` 스토리지 엔진의 경우 INSERT 문장 실행시,

**즉시 새로운 키 값을 B-Tree 인덱스에 반영**한다.

`InnoDB 스토리지 엔진`은 이 작업을 필요하다면 `지연`시켜 **나중에 처리**할 수 있다.

`프라이머리 키`나 `유니크 인덱스`의 경우 중복 체크가 필요하므로 **즉시 B-Tree 인덱스에 반영**한다.

### 🥱 인덱스 키 삭제

- `B-Tree`의 키 값이 삭제되는 경우는 `처리`가 `간단`하다.
- 해당 키 값이 저장된 `B-Tree` 리프 노드를 찾아서 **삭제 마크 처리**만 하면 된다.

`삭제 마킹`된 인덱스 키 공간은 그대로 `방치`하거나 `재활용`이 가능하다.

`인덱스 키` 삭제로 인한 `마킹 작업` 또한 디스크 쓰기가 필요하므로 **디스크 I/O가 발생**한다.

`InnoDB 스토리지 엔진`에서는 이 작업도 `버퍼링`되어 `지연 처리` 될 수 있다.

`MyISAM`이나 `MEMORY` 스토리지 엔진은 **인덱스 키 삭제가 완료되야 쿼리가 실행** 된다.

### 👽 인덱스 키 변경

- `인덱스`의 키 값 변경은 단순히 `인덱스` 상의 **키 값만 변경하도록 처리할 수 없다.**
- `B-Tree`의 키 값 변경 작업은 `키 값`을 삭제하고 다시 `새로운 키`를 추가하는 형태로 처리된다.
- `InnoDB 스토리지 엔진`을 사용하면 이 작업도 **체인지 버퍼를 활용해 지연 처리** 될 수 있다.

### 🤭 인덱스 키 검색

- `인덱스`를 검색하는 작업은 `B-Tree`의 루트 노드 부터 시작한다.
- `루트 노드` 부터 `브랜치 노드`를 거쳐 `최종 리프 노드`까지 이동하면서 **비교 작업을 수행**한다.

`인덱스 트리 탐색`은 **SELECT 뿐만 아니라 UPDATE, DELETE 처리를 위한 레코드 검색**에도 `이용`된다.

`B-Tree` 인덱스를 이용한 검색은 `100% 일치` 또는 **값의 앞부분만 일치**하는 경우에 `사용`할 수 있다.

`부등호 비교 조건`에서도 인덱스 사용은 가능하지만,

`인덱스`를 구성하는 **키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.**

`인덱스`를 이용한 검색에서 중요한 사실은 `인덱스`의 **키 값에 변형이 가해진 후 비교**되는 경우에는

`B-Tree`의 빠른 검색 기능을 사용할 수 없다.

`함수`나 `연산`을 수행한 결과로 `정렬`한다거나 `검색`하는 작업은 **B-Tree 장점을 이용할 수 없다**는 점에

`유의`해야 한다.

`InnoDB 테이블`에서 지원하는 `레코드 잠금`이나 `넥스트 키락`이 검색을 수행한 `인덱스`를 잠근 후

**테이블의 레코드를 잠그는 방식**으로 `구현`되어 있다.

`UPDATE`나 `DELETE` 문장이 실행될 때 테이블에 적절히 사용할 수 있는 `인덱스`가 없으면

불필요하게 `많은 레코드`를 잠그게 되며 테이블의 `모든 레코드`를 잠글 수도 있다.

`InnoDB 스토리지 엔진`은 그만큼 **인덱스의 설계가 매우 중요하고 많은 영향**을 미친다.

### 🤫 B-Tree 인덱스 사용에 영향을 미치는 요소

- `B-Tree 인덱스`는 인덱스를 구성하는 `컬럼`의 크기와 `레코드` 건수, `유니크한 인덱스` 키 값의 개수 등의 요인으로 **검색이나 변경 작업의 성능이 영향**을 받는다.

### 😒 인덱스 키 값의 크기

- `InnoDB 스토리지 엔진`은 디스크에 데이터를 저장하는 `기본 단위`를 **페이지 또는 블록**이라고 한다.
- 이 단위는 `디스크`의 모든 읽기 및 쓰기 작업의 `최소 단위`가 된다.
- `인덱스`도 `페이지 단위`로 관리되고, **루트와 브랜치 그리고 리프 노드를 구분하는 기준도 페이지 단위**다.

`B-Tree`는 `자식 노드`의 개수가 가변적인 구조다.

`MySQL`의 `B-Tree`는 `인덱스`의 **페이지 크기와 키 값의 크기에 따라서 자식 노드의 개수가 결정**된다.

`InnoDB 스토리지 엔진`의 페이지 크기를 `innodb_page_size` 변수로 `4~64KB` 사이로 선택할 수 있는데,

기본 값은 `16KB`로 되어 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/013a64fb-19d9-4ee2-9930-5168c6870312)

`인덱스`의 키가 `16 바이트`라고 가정하면, 위의 그림과 같이 `인덱스 페이지`가 `구성`된다.

`자식 노드 주소 영역`은 여러 가지 복합적인 정보가 담긴 영역이다.

페이지의 종류 별로 대략 `6바이트`에서 `12바이트`까지 다양한 크기의 값을 가질 수 있다.

`인덱스`를 구성하는 `키 값`의 크기가 커지면, `디스크`로부터 읽어야 하는 횟수가 늘어난다.

`인덱스 키 값`의 길이가 길어진다는 것은 **전체적인 인덱스의 크기가 커진다는 것을 의미**한다.

`인덱스`를 캐시해두는 `InnoDB`의 버퍼 풀이나 `MyISAM`의 키 캐시 영역은 **크기가 제한적**이므로,

`하나의 레코드`를 위한 인덱스 크기가 커지면 **메모리에 캐시해 둘 수 있는 레코드 수**는 줄어든다.

그렇게 되면 `메모리의 효율`이 **떨어지는 결과**를 가져온다.

### 🤔 B-Tree의 깊이

- B-Tree 인덱스의 깊이는 상당히 중요하지만 직접 제어할 수 없다.

`B-Tree`의 깊이가 `3`이라면 **최대 몇 개의 키 값**을 가질 수 있을까?

`인덱스 키 값`이 **16KB**인 경우와 **32KB**인 경우로 구분해보자.

- `16KB` : 최대 2억개
- `32KB` : 최대 5천만개

`B-Tree`의 깊이는 값을 검색할 때 몇 번이나 `랜덤`하게 **디스크를 읽어야 하는지**와 직결되는 문제다.

`인덱스 키 값`의 크기가 커지면 커질수록 하나의 `인덱스 페이지`가 담을 수 있는 인덱스 키 값의

개수가 적어지고, `디스크 읽기`가 **더 많이 필요하게 된다는 것을 의미**한다.

따라서, `인덱스 키 값`의 크기는 **가능하면 작게 만드는 것**이 좋다.

아무리 큰  대용량 데이터베이스라도 `B-Tree`의 깊이는 `5단계` 이상으로 **가는 경우는 흔치 않다.**

### 😛 선택도(기수성)

- 인덱스에서 `선택도(Selectivity)` 또는 `기수성(Cardinality)`은 **거의 같은 의미로 사용**된다.
- 모든 `인덱스 키 값` 가운데 **고유(Unique)한 값의 수**를 의미한다.

전체 `인덱스 값`이 `100개`인데, 고유한 값의 수는 `10개`라면 **기수성**이 `10`이다.

`인덱스 키 값` 가운데 중복된 값이 많아지면 `기수성`은 낮아지고 `선택도` 또한 떨어진다.

`인덱스`는 `선택도`가 **높을수록 검색 대상이 줄어**들기 때문에 그만큼 `빠르게 처리`된다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/219323b2-ff74-4ed9-9667-187519a16c26)

한 가지 간단한 예제로 `인덱스 설계`에 대해 생각해보자.

`country`라는 컬럼과 `city`라는 컬럼이 포함된 `tb_best` 테이블이 있다고 가정하고,

전체 레코드 수는 `1만 건`이며 `country 컬럼`으로만 **인덱스가 생성**되었다고 하자.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/f0729f4d-64dd-4f63-98fa-c08b0240dc98)

서로 `유니크한 값`의 개수가 다른 상황에서 어떤 차이가 있을까?

`MySQL`은 인덱스의 `통계 정보(유니크한 값의 개수)`가 관리되기 때문에, 

`city` 컬럼의 `기수성`은 **작업 범위에 아무런 영향을 주지 않는다.**

위의 쿼리를 실행하면 `A 케이스`는 **평균 1000건**, `B 케이스`는 **평균 10건**이 조회될 수 있다는 사실을

`인덱스의 통계정보`로 예측할 수 있다.

`A 케이스`와 `B 케이스` 모두 실제 모든 조건을 만족하는 레코드가 단 `1건`이라면,

`A 케이스`의 인덱스는 적합하지 않다.

`A 케이스`는 **1건의 레코드를 위해 쓸모없는 999건의 레코드를 더 읽은 셈**이 된다.

필요한 만큼의 `레코드`를 정확하게 읽을 수 있도록 `인덱스`를 `설계`하는 것은 어렵다.

아래와 같은 테이블에 `1만건`의 레코드가 있다고 가정하고,

`country` 컬럼만 **인덱스가 준비**되어 있고 `국가`와 `도시`는 **중복 값이 없다고 가정**한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/adba95c1-ce66-4fd6-b4dd-e67368566573)

`tb_city` 테이블에 아래와 같은 쿼리를 실행하면 `인덱스`의 `효율성`이 어떨까?

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/0275a7c4-f015-4bae-80d9-bfc535587b3c)

- `country 컬럼`의 **유니크 값이 10개일 때**

전체 레코드 건수를 `유니크한 값`의 개수로 나눠보면 `하나의 키 값`으로 `검색`했을 때 대략 몇 건의 레코드가

일치할 지 예측할 수 있게 된다.

`country=’KOREA’` 라는 조건으로 인덱스를 검색하면 `1000건`이 일치한다는 것을 예상할 수 있다.

인덱스를 통해 검색된 `1000건` 가운데 `city=’SEOUL’`인 레코드는 `1건`이므로 **999건을 불필요**하게

읽게 되었다.

- `country 컬럼`의 **유니크 값이 1000개일 때**

전체 레코드 건수를 국가 컬럼의 유니크 값 개수로 나눠보면 대략 `10개` 정도로 `예측`할 수 있다.

`city=’SEOUL’` 인 레코드는 `1건`이므로 **10건 중 9건만 불필요**하게 읽게 된 것이다.

`테이블`에서 똑같은 쿼리를 실행해도, `인덱스`에서 **유니크 값의 개수에 따라서 쿼리의 효율성**이 달라진다.

### 😲 읽어야 하는 레코드의 건수

- `인덱스`를 통해 `테이블`의 레코드를 읽는 것은 `인덱스`를 거치지 않는 것보다 비용이 높다.

예를 들어, 테이블에 레코드가 `100만건` 저장되어 있을때 `50만건`을 읽는 `쿼리`가 있다고 가정하자.

이 작업이 `전체 테이블`을 모두 읽어서 **필요 없는 50만건을 버리는 것**이 `효율적`일지,

`인덱스`를 통해 **필요한 50만 건만 읽어 오는 것**이 `효율적`일지 `판단`해봐야 한다.

`인덱스`를 이용한 읽기의 `손익 분기점`이 얼마인지 `판단`할 `필요성`이 있는데,

일반적인 `DBMS`의 `옵티마이저`는 **인덱스를 통해 레코드를 읽는 것**이 직접 테이블에서 읽는 것보다

`4~5배` 정도의 `비용`이 드는 것으로 `예측`한다.

`인덱스`를 통해 읽어야 할 `레코드의 건수`가 **전체 테이블 레코드의 20~25%**를 넘어서면,

`인덱스`를 이용하지 않고 `테이블`을 모두 읽어서 **필요한 레코드만 가려내는 방식의 처리**가 더 좋다.

전체 `100만 건`의 레코드 가운데 `50만 건`을 읽어야 하는 작업은 `인덱스 손익 분기점`보다 **훨씬 크다.**

따라서 `옵티마이저`는 인덱스를 이용하지 않고 `테이블`을 `풀스캔`해서 처리할 것이다.

이런 상황에서 `옵티마이저`에게 힌트를 제공해서 **강제로 인덱스를 사용하게 추가**해도,

`옵티마이저`는 기본적으로 `힌트`를 무시하고 `테이블`을 **직접 읽는 방식으로 처리**할 것이다.

### 🥇 B-Tree 인덱스를 통한 데이터 읽기

- 어떤 경우에 `인덱스`를 사용하게, 또는 사용하지 않게 `유도`할지 `판단`해야 한다.
- `MySQL`의 각 `스토리지 엔진`이 어떻게 **인덱스를 이용하는지 알아야 최적화**가 가능하다.

### 😃 Index Range Scan(인덱스 레인지 스캔)

- `인덱스`의 접근 방법 가운데 가장 `대표적인 접근 방식`이다.

```sql
mysql> SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

위와 같은 `쿼리`가 있다고 할때, 어떻게 `인덱스`를 `이용`하는지 살펴보자

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/8516ac06-d4ac-4140-99e2-f83a8e54fc2b)

`Index Range Scan`은 **검색해야 할 인덱스의 범위가 결정**됐을 때 `사용하는 방식`이다.

**검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이** `Range Scan` 이라고 표현한다.

`루트 노드`에서 비교를 시작해서 `브랜치 노드`를 거치고 `리프 노드`까지 찾아 들어간다.

그래야만 필요한 `레코드의 시작 지점`을 찾을 수 있다.

시작할 위치를 찾으면 그때부터는 `리프 노드`의 레코드만 순서대로 읽고,

`리프 노드`의 끝까지 읽으면 `리프 노드` 간의 링크를 이용해 다음 `리프 노드`를 찾아서 `스캔`한다.

`스캔`을 멈춰야 할 위치에 다다르면 **지금까지 읽은 레코드를 사용자에게 반환**한다.

위의 그림은 `인덱스`만을 읽는 경우를 보여준다.

`B-Tree` 인덱스의 `리프 노드`를 스캔하면서 `실제 데이터 파일`의 **레코드를 읽어 와야 하는 경우도 생긴다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/6a828d9f-ca69-40e0-b063-81af9a9c4c65)

`B-Tree 인덱스`에서 `스캔 시작 위치`를 `검색`하고, 그 지점부터 **필요한 방향(오름차순 or 내림차순)**으로

`인덱스`를 읽어 나가는 과정이 위의 그림에 표현되어 있다.

어떤 방식으로 스캔하든 관계없이, 해당 `인덱스를 구성하는 컬럼`의 **정순 또는 역순으로 정렬된 상태**로

`레코드`를 가져온다는 사실이 중요하다.

인덱스의 `리프 노드`에서 검색 조건에 일치하는 건들은 `데이터 파일`에서 `레코드`를 읽어와야 하는데,

`리프 노드`에 저장된 레코드 주소로 **데이터 파일의 레코드를 읽어온다.**

`레코드` 한 건 한 건 단위로 `랜덤 I/O`가 한 번씩 일어나게 된다.

따라서 `인덱스`를 통해 `데이터 레코드`를 읽는 작업은 **비용이 많이 드는 작업으로 분류**된다.

`Index Range Scan`은 아래와 같이 3단계를 거친다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/b2d425c1-6331-46f2-b98a-db3c9980441e)

`쿼리`가 필요로 하는 `데이터`에 따라서 **3번 과정은 생략**될 수 있다.

`커버링 인덱스`로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 `랜덤 I/O`가 많이 줄어든다.

`MySQL 서버`에서는 **1번과 2번 단계의 작업이 얼마나 수행되었는지** `상태값`으로 `확인`할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/18fabbf3-2fca-4af8-a861-b8dda8c327bd)

- `Handler_read_key` : 1번 단계가 실행된 횟수
- `Handler_read_next` : 인덱스 정순으로 읽은 레코드 건수
- `Handler_read_prev` : 인덱스 역순으로 읽은 레코드 건수
- `Handler_read_first` : 인덱스의 첫 번째 레코드를 읽은 횟수, `MIN()` 함수 사용시 증가
- `Handler_read_last` : 인덱스의 마지막 레코드를 읽은 횟수, `MAX()` 함수 사용시 증가

### 😶 Index Full Scan

- `인덱스`의 **처음부터 끝까지 모두 읽는 방식**을 말한다.
- `쿼리`의 조건절에 사용된 `컬럼`이 **인덱스의 첫 번째 컬럼이 아닌 경우 사용**된다.

인덱스는 `(A, B, C)` 컬럼의 순서로 만들어져 있지만 `쿼리`의 `조건절`이 **B나 C 컬럼으로 검색**할 때

`Index Full Scan` 방식으로 동작한다.

`인덱스`의 크기는 테이블의 크기보다 작기 때문에 직접 `테이블을 풀스캔` 하는 것 보다는

`인덱스`만 **읽는 것이 효율적**이다.

`쿼리`가 인덱스에 명시된 `컬럼`만으로 조건을 처리할 수 있는 경우에는 이 방식이 사용되고,

`인덱스`뿐만 아니라 `데이터 레코드`까지 모두 읽어야 한다면 **이 방식으로 처리되지 않는다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/73e1a2c3-056a-4f77-a238-753ec6c5c3aa)

`Index Full Scan`이 어떤 방식으로 `수행`되는지 살펴보면 아래와 같다.

1. `인덱스 리프 노드`의 제일 앞 또는 제일 뒤로 이동한다.
2. `인덱스`의 `리프 노드`를 연결하는 `링크드 리스트`를 따라서 **처음부터 끝까지 스캔**한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/2e8921ba-b942-4dbf-921e-955bc10c6a7c)

### 🤔 Loose Index Scan

- 오라클의 `Index Skip Scan`과 **작동 방식이 비슷한 방식**이다.
- `MySQL 8.0` 버전부터 다른 상용 `DBMS`에서 지원하는 `Index Skip Scan`과 같은 **최적화를 지원**하기 시작했다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d175e63a-99ba-4fab-9d0e-21a56ddf9236)

`Loose Index Scan`은 `Index Range Scan`과 비슷하게 작동하지만,

중간에 `필요하지 않은 인덱스 키 값`은 **무시하고 다음으로 넘어가는 형태**로 처리된다.

보통 `GROUP BY`또는 집계 함수 중 `MIN()`과 `MAX()`에 **최적화를 하는 경우 사용**된다.

```sql
mysql> SELECT dept_no, MIN(emp_no),
       FROM dept_emp
       WHERE dep_no BETWEEN 'd002' AND 'd004'
       GROUP BY dept_no;
```

이 쿼리에서 사용된 `dept_emp` 테이블은 `dept_no`와 `emp_no`라는 **두 개의 컬럼으로 인덱스가 생성**되어 있다.

이 인덱스는 `(dept_no, emp_no)` 조합으로 정렬되어 있어서 

`dept_no` 그룹별로 첫 번째 레코드의 `emp_no` 값만 읽으면 된다.

`옵티마이저`는 인덱스에서 **WHERE 조건을 만족하는 범위를 다 스캔할 필요가 없다는 것**을 알고 있다.

`Loose Index Scan`을 사용하려면 **여러 가지 조건이 만족**되어야 한다.

### 💣 Index Skip Scan

- `데이터 베이스 서버`에서 인덱스의 `핵심`은 **값이 정렬되어 있다는 것**이다.
- 따라서, `인덱스`를 구성하는 `컬럼`의 `순서`가 `매우 중요`하다.

```sql
mysql> ALTER TABLE employees
       ADD INDEX ix_gender_birthdate (gender, birth_date);
```

위와 같은 `인덱스`를 생성했다고 가정해보자.

```sql
-- 인덱스 사용하지 못함
mysql> SELECT * FROM employees WHERE birth_date >= '1965-02-01';

-- 인덱스 사용가능
mysql> SELECT * FROM employees WHERE gender='M' AND birtch_date >= '1965-02-01';
```

`gender` 컬럼과 `birth_date` 컬럼의 조건을 **모두 가진 쿼리를 인덱스를 효율적으로 사용**할 수 있다.

첫 번째 쿼리에서 `인덱스`를 사용하려면 `birth_date` 컬럼부터 **시작하는 인덱스를 새로 생성**해야 했다.

`8.0 버전`부터는 `옵티마이저`가 `gender` 컬럼을 건너뛰어서 `birth_date` 컬럼만으로 `인덱스 검색`이 가능한

`Index Skip Scan` **최적화 기능이 도입**되었다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/89268ec5-4612-4ee7-a05c-3b3c61647090)

`Index Skip Scan`을 비활성화하고 `실행 계획`을 살펴보면 위와 같다.

`WHERE` 조건절에 `gender` 컬럼에 대한 조건 없이 `birth_date` 컬럼의 `비교 조건`만 가지고 있기 때문에

`ix_gender_birthdate` 인덱스를 효율적으로 이용할 수 없다.

실행 계획에서 `type`이 `“index”`라면 `인덱스`를 처음부터 끝까지 모두 읽었다는 뜻이다.

이 쿼리는 `gender` 컬럼과 `birth_date` 컬럼만 있으면 처리할 수 있기 때문에

`ix_gender_birthdate` **인덱스를 풀 스캔**한 것이다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/a4e7ea52-609b-4bc0-a126-b27c5fe719a5)

이제 다시 `Index Skip Scan`을 활성화하고 다시 `실행 계획`을 살펴보면 위와 같다.

실행 계획에서 `type` 컬럼의 값이 `“range”`로 표시되어 있는데,

`인덱스`에서 꼭 필요한 부분만 읽었다는 것을 `의미`한다.

`Extra` 컬럼에 `“Using index for skip scan”` 이라는 문구가 표시됐는데,

`ix_gender_birthdate` 인덱스에 대해 `Index Skip Scan`을 활용했다는 뜻이다.

MySQL `옵티마이저`는 `gender` 컬럼에서 **유니크한 값을 우선 모두 조회**해서 주어진 쿼리에

`gender` 컬럼의 조건을 추가해서 **쿼리를 다시 실행**하는 형태로 처리한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/6e94b43c-ce44-4652-b38a-9a893e53429b)

`gender 컬럼`은 성별을 구분하는 `컬럼`으로 **‘M’과 ‘F’ 값만 가지는 ENUM 타입**이다.

따라서 `gender` 컬럼에 가능한 값 `2개`를 사전에 구한뒤에 `옵티마이저`는 아래와 같이 `쿼리`를 `실행`해서

**최적화를 수행**하게 되는 것이다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/f316fa30-0c72-422e-bc28-558a9944f60f)

`Index Skip Scan`은 8.0 버전에 도입되어 아직은 아래와 같은 단점이 있다.

- `WHERE 조건절`에 조건이 없는 인덱스의 `선행 컬럼`의 **유니크한 값의 개수가 적어야 한다**.
- `쿼리`가 인덱스에 존재하는 `컬럼`만으로 처리가 가능해야 한다(**커버링 인덱스**)

첫 번째 조건은 `쿼리 실행 계획`의 `비용`과 관련된 부분이다.

유니크한 값의 개수가 매우 많다면 `옵티마이저`는 인덱스에서 `스캔`해야 할 

`시작 지점`을 검색하는 작업이 많이 필요해진다. 

그래서 오히려 `쿼리의 처리 성능`이 더 느려질 수 있다.

예를 들어 `(emp_no, dept_no)` 조합으로 만들어진 인덱스에서 `Skip Scan`을 실행한다면,

사원의 수만큼 `Range Scan` 시점을 검색하는 작업이 필요해져 `쿼리`의 `성능`이 매우 떨어진다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/497f3ce6-ede8-4884-860e-5bc699a8c092)

위의 쿼리는 `WHERE` 조건절은 도일하지만 `employees` 테이블의 **모든 컬럼을 조회하도록 변경**했다.

`ix_gender_birthdate` 인덱스에 포함된 `컬럼`만으로 쿼리를 실행할 수 없기 때문에 `풀 테이블 스캔`으로

`실행 계획`이 수립되어 실행되는 것을 볼 수 있다.

### 😆 다중 컬럼(Multi-Column) 인덱스

- **실제 서비스용 데이터베이스**에서는 `2개` 이상의 컬럼을 포함하는 `인덱스`가 더 많이 사용된다.
- `두 개` 이상의 `컬럼`으로 구성된 인덱스를 `다중 컬럼 인덱스`라고 한다.
- `2개` 이상의 `컬럼`이 연결됐다고 해서 `Concatenated Index`라고 부르기도 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/abd49c7e-5a3d-4e5e-99c8-fe08dad768d9)

`데이터 레코드 건수`가 작은 경우에는 `브랜치 노드`가 없는 경우가 있을 수 있다.

하지만 `루트 노드`와 `리프 노드`는 항상 존재한다.

위의 그림에서 중요한 것은 `인덱스`의 **두 번째 컬럼**은 `첫 번째 컬럼`에 **의존해서 정렬**돼 있다는 것이다.

`두 번째 컬럼`의 정렬은 `첫 번째 컬럼`이 **같은 레코드에서만 의미**가 있다는 의미가 된다.

`emp_no` 값의 정렬 순서가 빠르다고 하더라도 `dept_no 컬럼`의 **정렬 순서가 늦다면 인덱스의 뒤쪽에 위치**한다.

따라서, `인덱스` 내에서 각 `컬럼`의 위치가 상당히 중요하기 때문에 **신중히 결정**해야 하는 것이다.

### 😲 B-Tree 인덱스의 정렬 및 스캔 방향

- `인덱스`를 생성할 때 설정한 `정렬 규칙`에 따라서 `인덱스`는 **항상 오름차순 또는 내림차순으로 정렬되어 저장**된다.
- `인덱스`의 `정렬 규칙`에 따라서 항상 그 규칙으로만 읽을 수 있는 것은 아니다.
- `인덱스`를 어느 방향으로 읽을지는 `쿼리`에 따라 **옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정**된다.

### 💯 인덱스의 정렬

- `인덱스`를 구성하는 각 `컬럼`의 정렬을 **오름차순 또는 내림차순으로 설정**할 수 있다.
- `5.7 버전`까지는 `컬럼` 단위로 **정렬 순서를 혼합해서 인덱스를 생성**할 수 없었다.
- `숫자 컬럼`의 경우 `-1`을 **곱한 값을 저장하는 우회 방법을 사용**하는 경우가 많았다.

`8.0 버전`부터는 아래와 같은 형태의 `정렬 순서`를 `혼합`한 **인덱스 생성이 가능**해졌다.

```sql
mysql> CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3629b011-1523-4143-8831-070bdd08293f)

### 🧛🏼 인덱스 스캔 방향

`first_name` 컬럼에 대한 인덱스가 포함된 `employees` 테이블에 대해 **아래의 쿼리를 실행하는 과정**을 살펴보자.

```sql
mysql> SELECT * 
       FROM
       ORDER BY first_name DESC
       LIMIT 1;
```

이 `쿼리`를 실행하기 위해서 `인덱스`를 처음부터 끝까지 읽어서 최대 값을 가져올까?

`옵티마이저`는 인덱스가 `오름차순`으로 정렬되어 있어도 `최댓값`부터 거꾸로 읽으면 값을 가져올 수 있다는 

`사실`을 이미 알고 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/4ebd1c5a-019c-4d1c-8ba4-fc273e74a6b9)

`인덱스 생성 시점`에 **오름차순 또는 내림차순으로 정렬**이 결정되지만,

`쿼리`가 `인덱스`를 사용하는 시점에 **인덱스를 읽는 방향에 따라서 정렬 효과**를 얻을 수 있다.

그렇다면 아래의 쿼리들을 어떻게 실행될까?

```sql
mysql> SELECT * FROM employees WHERE first_name >= 'Anneke'
       ORDER BY first_name ASC LIMIT 4;
       

mysql> SELECT * FROM employess
       ORDER BY first_name DESC LIMIT 5;
```

첫 번째 쿼리는 `first_name` 컬럼에 정의된 인덱스를 이용해 `“Anneke”` 레코드를 찾고,

정렬 순으로 `인덱스`를 읽으면서 `4개`의 **레코드만 가져오면 아무런 비용**이 들지 않는다.

두 번째 쿼리는 `employees` 테이블의 `first_name` 컬럼에 **정의된 인덱스를 역순**으로 읽으면서

처음 `다섯 개`의 레코드만 가져오면 된다.

쿼리의 `ORDER BY` 처리나 `MIN()`또는 `MAX()` 함수 등의 최적화가 필요한 경우에도

`MySQL 옵티마이저`는 **인덱스의 읽기 방향을 전환해서 사용**하도록 `실행 계획`을 만들어 낸다.

### 😁 내림차순 인덱스

`MySQL` 서버에서 아래의 두 쿼리는 `내림차순`인지 `오름차순`인지와 관계없이 인덱스를 읽는

순서만 변경해서 `해결`할 수 있었다.

```sql
mysql> SELECT * FROM employees ORDER BY first_name ASC  LIMIT 10;
mysql> SELECT * FROM employees ORDER BY first_name DESC LIMIT 10;
```

아래와 같이 `2개` 이상의 `컬럼`으로 구성된 `복합 인덱스`에서도 각각의 컬럼이 내림차순과 오름차순이

`혼합`된 경우에는 `MySQL 8.0`의 **내림차순 인덱스만으로 해결**될 수 있다.

`first_name` 컬럼을 `역순`으로 정렬하는 요건만 있다면, 

**아래의 2개의 인덱스 중에서 어떤 것을 선택하는 것이 좋을까?**

```sql
mysql> CREATE INDEX ix_firstname_asc  ON employees (first_name ASC );
mysql> CREATE INDEX ix_firstname_desc ON employees (first_name DESC);
```

이 문제에 대한 답을 찾으려면 `8.0 버전`부터 지원되는 **내림차순 인덱스에 대해 깊이있게 알아야한다.**

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/f434f898-f59f-43a6-afa9-75ade477f9d7)

- `오름차순 인덱스` : 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- `내림차순 인덱스` : 큰 값의 키가 B-Tree의 왼쪽으로 저장된 인덱스
- `인덱스 정순 스캔` : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- `인덱스 역순 스캔` : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔

```sql
mysql> CREATE TABLE t1 (
         tid INT NOT NULL AUTO_INCREMENT,
         TABLE_NAME VARCHAR(64),
         COLUMN_NAME VARCHAR(64),
         ORDINAL_POSITION INT,
         PRIMARY KEY(tid)
       ) ENGINE=InnoDB;
```

위와 같은 `테이블`을 생성하고 `1천만 건` 정도의 레코드를 넣었다고 가정해보자.

이 테이블을 `풀 스캔`하면서 **정렬만 수행하는 쿼리**를 아래와 같이 `실행`해보자.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/0dce06e2-cf32-421d-bead-080c7502a117)

`tid 컬럼`의 **값이 가장 크고 작은 레코드를 각각 1건 반환**하는 쿼리지만,

`LIMIT … OFFSET` 부분의 쿼리로 인해 `MySQL` 서버는 **테이블의 모든 레코드를 스캔**해야 한다.

`물리적`으로 `1.2초` 정도의 차이가 나지만, 비율로 따졌을 때 **역순 정렬 쿼리가 28.9% 시간이 더 걸린다.**

하나의 `인덱스`를 `정순`으로 읽느냐 또는 `역순`으로 읽느냐에 따라 이런 차이가 발생한다.

`InnoDB` 스토리지 엔진에서 `정순 스캔`과 `역순 스캔`은 페이지간의 양방향 연결 고리를 통해,

`전진` 하느냐 `후진` 하느냐의 차이만 있다.

하지만 내부적으로 `InnoDB`에서 역순 스캔이 정순 스캔보다 느릴 수 밖에 없는 이유가 있다.

- `페이지 잠금`이 인덱스 정순 스캔에 적합한 구조를 가짐
- `페이지` 내에서 인덱스 레코드가 단방향으로만 연결된 구조를 가짐

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/67755a64-d59f-4c91-ae85-19af0b42b43c)

이 그림을 살펴보면 `InnoDB 페이지` 내부에서 **레코드들이 단방향으로만 링크를 가진 것**을 볼 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/80bac61b-8e71-48e2-b3b2-22fd968cd195)

`서비스 요건`에 맞게 어떤 정렬 순서의 인덱스를 선택하는 것이 좋을지 살펴보자.

일반적으로 인덱스를 `ORDER BY … DESC` 하는 쿼리가 **소량의 레코드에 드물게 실행**된다면,

`내림차순 인덱스`를 굳이 고려하지 않아도 될 것이다.

```sql
mysql> SELECT * FROM tab
       WHERE userid=?
       ORDER BY score DESC
       LIMIT 10;
```

이 쿼리의 경우 아래 `두 가지 인덱스` 모두 적절한 선택지가 될 수 있다.

```sql
오름차순 인덱스 : INDEX (userid ASC, score ASC)
내림차순 인덱스 : INDEX (userid DESC, score DESC)
```

하지만 `많은 레코드`를 `조회`하면서 `빈번`하게 **내림차순 쿼리가 실행**된다면,

`내림차순 인덱스`를 사용하는 것이 더 효율적이라고 할 수 있다.

`많은 쿼리`가 인덱스의 `앞쪽`이나 `뒤쪽`만 집중적으로 읽어서 **인덱스의 특정 페이지 잠금이 병목**이 될 것으로

예상되는 경우, `쿼리`에서 자주 `사용`되는 **정렬 순서대로 인덱스를 생성**하는 것이 좋다.

### 😲 B-Tree 인덱스의 가용성과 효율성

- `쿼리`의 `WHERE` 조건이나 `GROUP BY`, `ORDER BY` 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.
- 위의 내용을 식별해야, `쿼리의 조건`을 최적화하거나, `쿼리`에 맞게 **인덱스를 최적으로 생성**할 수 있다.

### 👽 비교 조건의 종류와 효율성

- `다중 컬럼 인덱스`에서 각 `컬럼`의 순서와 그 `컬럼`에 사용된 조건이 **동등 비교인지 등호 비교인지**에 따라서 인덱스 활용 형태가 달라진다.

```sql
mysql> SELECT * FROM dept_emp
       WHERE dept_no='d002' AND emp_no >= 10114;
```

위 쿼리를 위해서 `컬럼`의 순서만 다른 두 가지 케이스의 `인덱스`를 `생성`했다고 `가정`해보자.

- `케이스 A` : INDEX (dept_no, emp_no)
- `케이스 B` : INDEX (emp_no, dept_no)

`케이스 A` 인덱스는 `dept_no=’d002`’ AND `emp_no ≥ 10144`인 레코드를 찾고,

그 이후에는 `dept_no`가 **d002가 아닐 때까지 인덱스를 쭉 읽기만 하면 된다.**

이 경우 조건을 만족하는 레코드가 `5건`이라고 할 때, `5건`의 레코드를 찾는 데 꼭 필요한

**5번의 비교 작업만 수행**한 것이므로 상당히 `효율적`으로 `인덱스`를 `사용`했다고 할 수 있다.

`케이스 B`는 **emp_no ≥ 10144 AND dept_no=’d002’**인 레코드를 찾고,

모든 레코드에 대해 `dept_no`가 `d002`인지 비교하는 과정을 거쳐야 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/8e1e9827-cd40-4369-917e-48abc8e49433)

`인덱스`를 통해 읽은 `레코드`가 나머지 조건에 맞는지 비교하면서 취사선**택하는 작업을 필터링**이라고 한다.

최종적으로 `케이스 B`도 조건을 만족하는 레코드 `5건`을 반환하지만, `7번`의 `비교 과정`을 거친다.

이런 현상이 발생하는 이유는 `다중 컬럼 인덱스`의 정렬 방식이 

인덱스의 `N번째 키` 값은 `N-1번째 키` 값에 대해서 **다시 정렬되도록 동작**하기 때문이다.

`케이스 A`의 인덱스에서 `emp_no`는 비교 작업의 범위를 좁히는 데 도움을 주지만,

`케이스 B`의 인덱스에서 `dept_no`는 비교 작업의 범위를 좁히는 데 아무런 도움을 주지 않는다.

`케이스 A` 인덱스에서의 두 조건과 같이 **작업의 범위를 결정하는 것을 작업 범위 결정 조건**이라하고,

`케이스 B` 인덱스의 `dept_no=’d002’` 와 같이 비교 작업의 범위는 줄이지 못하고 **단순히 거르는 역할만**

**하는 조건을 필터링 조건 또는 체크 조건**이라고 한다.

`작업 범위`를 결정하는 조건은 **많으면 많을수록 쿼리의 처리 성능**을 높이지만,

`체크 조건`은 많다고 해서 **쿼리의 처리 성능**을 높이지는 못하고, `쿼리 실행`을 더 느리게 만들 때가 많다.

### 🙁 인덱스의 가용성

- `B-Tree 인덱스`의 특징은 **왼쪽 값에 기준해서 오른쪽 값이 정렬**되어 있다는 것이다.
- `왼쪽`이란 하나의 `컬럼` 내에서뿐만 아니라 **다중 컬럼 인덱스의 컬럼에 대해서도 함께 적용**된다.

- `케이스 A` : INDEX (fisrt_name)
- `케이스 B` : INDEX (dept_no, emp_no)

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/d76c23e5-7a5a-4995-ac3c-1202f37ce99d)

`인덱스 키 값`의 정렬 특성은 **빠른 검색의 전제 조건**이 된다.

`하나의 컬럼`으로만 검색해도 값의 왼쪽 부분이 없으면 `Index Range Scan`이 불가능하다.

`다중 컬럼 인덱스`에서도 왼쪽 컬럼의 값을 모르면 **Index Range Scan**을 사용할 수 없다.

`케이스 A`의 인덱스가 지정된 `employees` 테이블에 대해 **아래와 같은 쿼리가 어떻게 실행**되는지 보자.

```sql
mysql> SELECT * FROM employees WHERE first_name LIKE '%mer';
```

이 쿼리는 `Index Range Scan` 방식으로 인덱스를 이용할 수 없다.

`first_name` 컬럼에 저장된 `왼쪽`부터 **한 글자씩 비교**해가면서 레코드를 찾아야 하는데,

조건절에 주어진 `상수값`에는 **왼쪽 부분이 고정**되지 않았기 때문이다.

`정렬 우선순위`가 낮은 뒷부분의 값으로는 `왼쪽 기준` 정렬 기반의 인덱스인 `B-Tree`의 효과를 

얻을 수 없기 때문이다.

`케이스 B`의 인덱스가 적용된 `dept_emp` 테이블에 대해 아래 `쿼리`가 어떻게 `실행`될까?

```sql
mysql> SELECT * FROM dept_emp WHERE emp_no >= 10144;
```

인덱스가 `(dept_no, emp_no)` 컬럼 순서대로 생성되어 있다면,

인덱스의 선행 컬럼인 `dept_no` 조건 없이 `emp_no` 값으로만 검색했을때 **인덱스를 효율적으로 사용할 수 없다.**

### 🫠 가용성과 효율성 판단

- `B-Tree` 인덱스의 특성상 `여러 조건`에서 사용할 수 없는 경우가 있다.
- 사용할 수 없다는 의미는 `작업 범위 결정 조건`으로 **사용할 수 없다는 것**을 의미한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/ddc846db-385a-47b3-9910-75a4c0b91e5d)

일반적인 `DBMS`에는 `NULL` 값이 인덱스에 저장되지 않지만,

`MySQL`은 `NULL` 값도 인덱스에 저장되는 것을 허용한다.

```sql
mysql> ... WHERE column IS NULL ..
```

따라서 위와 같은 쿼리의 `WHERE 조건`도 **작업 범위 결정 조건으로 인덱스를 사용**한다.

그렇다면 `다중 컬럼`으로 만들어진 `인덱스`는 어떤 조건에서 사용될 수 있을까?

```sql
INDEX ix_test ( column_1, column_2, column_3, .., column_n)
```

위와 같은 `인덱스`가 있을 때 어떤 경우 `인덱스`를 `사용`할 수 있는지 살펴보자

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/dc819dc7-ebc7-4361-8a7d-6cca60c9fcd1)

위의 두 가지 조건을 모두 만족하는 쿼리는 column_1 부터 column_i 까지는 작업 범위 결정 조건으로 사용된다.

`column_(i+1)` ~ `column_n` 까지의 조건은 **체크 조건으로 사용**된다.

`인덱스`를 사용하는 경우와 그렇지 않은 상황에 해당하는 `쿼리`를 몇 가지 살펴보겠다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/6180f0c5-1536-4d97-b2f5-1fe9e283d2a8)
![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/3cc3f7e2-54b2-4908-94ff-6eddf48025ad)


`작업 범위 결정 조건`으로 인덱스를 사용하는 `쿼리 패턴`은 상당히 많이 있지만,

대표적인 것들만 기억해 두면 좀 더 `효율적인 쿼리`를 **작성하는데 도움**이 된다.

### 👹 R-Tree 인덱스

- `공간 인덱스`는 **R-Tree 인덱스 알고리즘을 이용**해 `2차원의 데이터`를 **인덱싱하고 검색하는 목적의 인덱스**다.
- 기본적인 내부 메커니즘은 `B-Tree`와 흡사하다.

최근 위치 기반 서비스 활용이 높아지면서, `MySQL`의 공간 확장을 이용해서 간단하게 `기능`을 `구현`할 수 있다.

`MySQL`의 공간 확장에는 아래와 같이 크게 **세 가지 기능이 포함**되어 있다.

- `공간 데이터`를 저장할 수 있는 **데이터 타입**
- `공간 데이터`의 검색을 위한 **공간 인덱스(R-Tree 알고리즘)**
- `공간 데이터`의 **연산 함수(거리 또는 포함 관계의 처리)**

### 👾 구조 및 특성

- `MySQL`은 공간 정보의 저장 및 검색을 위해 **여러 가지 기하학적 도형 정보**를 관리할 수 있다.
- `MySQL`은 기하학적 도형 정보를 관리하기 위한 **여러가지 데이터 타입을 제공**한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/1183959b-738c-4d97-8996-6a4276a5ae69)

`GEOMETRY` 타입은 나머지 3개 타입의 슈퍼 타입이며,

`POINT`, `LINE`, `POLYGON` 객체를 모두 저장할 수 있다.

공간 검색을 위한 `R-Tree 알고리즘`을 이해하려면 **MBR 개념을 이해**해야 한다.

`MBR(Minimum Bounding Rectangle)` 이란 해당 도형을 감싸는 **최소 크기의 사각형을 의미**한다.

결국 `R-Tree 인덱스`는 이 사각형들의 포함 관계를 **B-Tree 형태로 구현**한 것을 말한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/c530e1c8-b365-4a7c-a4e3-af8c80f6e181)

이제 간단히 `R-Tree`의 구조를 살펴보겠다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/2ec69505-1706-4fcb-b93d-38318a4ff11b)

`X 좌표`와 `Y 좌표`만 있는 `포인트 데이터` 또한 **하나의 도형 객체**가 될 수 있다.

이러한 `도형`이 저장될 때 만들어지는 `인덱스의 구조`를 이해하려면 ,

이 도형들의 `MBR`이 어떻게 되는지 알아야 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/428f9f6d-107b-40dc-8849-e4ad8b7343a2)

도형들의 `MBR`을 3개의 레벨로 나눠 그린 그림인데, `세분화` 시켜보면 아래와 같다.

- `최상위 레벨` : R1, R2
- `차상위 레벨` : R3, R4, R5, R6
- `최하위 레벨` : R7 ~ R14

최하위 레벨의 `MBR`은 각 도형 테이터의 `MBR`을 의미한다.

차상위 레벨의 `MBR`은 **중간 크기의 MBR을 의미**하고, 최상위 `MBR`은 **R-Tree의 루트 노드에 저장되는 정보**이다.

`차상위 노드`의 MBR은 `R-Tree`의 **브랜치 노드**가 된다.

각 `도형`의 객체는 `리프 노드`에 저장되므로 `R-Tree` 인덱스의 내부는 아래와 같이 표현할 수 있다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/9673b43a-a900-49a4-bf7d-e3b8506c913e)

### 🤓 R-Tree 인덱스의 용도

- `R-Tree` 인덱스는 `GPS` 기준의 위도, **경도 좌표 저장에 주로 사용**된다.
- `CAD/CAM` 소프트웨어 또는 `회로 디자인` 등과 같이 **좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용**이 가능하다.

`R-Tree`는 도형의 포함 관계를 이용해 만든 인덱스이므로, `ST_Contains()` 또는 `ST_Within()`과 같이 

**포함 관계를 비교하는 함수로 검색을 수행**하는 경우에만 `인덱스 이용`이 `가능`하다.

예를 들어, 현재 사용자의 위치로부터 `반경 5KM` 이내의 **음식점 검색**과 같은 검색에 사용할 수 있다.

현재 출시되는 버전에서는 `거리`를 `비교`하는 `함수`는 **공간 인덱스를 효율적으로 사용하지 못한다.**

따라서, `공간 인덱스`를 사용할 수 있는 `ST_Contains()`나 `ST_Within()`을 이용해서 **거리 기반 검색**을 해야 한다.

![image](https://github.com/AK-47-Study/real-mysql-study/assets/91787050/eab89196-bd76-48cb-b05e-7b3a8a9d6a9b)

가운데 위치한 `P`가 `기준점`이 되고, **기준점으로부터 반경 5KM 이내의 위치를 검색**하려면,

`사각 점선 상자`에 **포함되는 점들을 검색**하면 된다.

`ST_Contains()`나 `ST_Within()` 연산은 **사각형 박스와 같은 다각형으로만 연산**할 수 있으므로,

반경 `5KM`를 그리는 `원`을 포함하는 `최소 사각형(MBR)`으로 **포함관계 비교를 수행**하게 된다.

점 `P6`는 기준점 `P`로 부터 반경 `5KM` 이상 떨어져 있지만 **최소 사각형 내에는 포함**된다.

`P6`를 빼고 `결과`를 `조회`하려면 **조금 더 복잡한 비교가 필요**하다.

```sql
mysql> SELECT * FROM tb_location
       WHERE ST_Contains(사각 상자, px);
       

mysql> SELECT * FROM tb_location
       WHERE ST_Within(px, 사각상자);
```

`P6`가 포함되어도 무방한 경우에는, 위의 `쿼리`와 같이 `작성`할 수 있다.

`ST_Contains()` 함수와 `ST_Within()` 함수는 거의 `동일한 비교`를 수행하지만,

**두 함수의 파라미터는 반대로 사용**해야 한다.

`ST_Contains()` 함수는 첫 번째 `파라미터`로 포함 경계를 가진 도형을 명시하고,

두 번째 `파라미터`로 포함되는 도형을 명시해야 한다.

`ST_Within()` 함수는 **첫 번째 파라미터로 포함되는 도형을 명시**하고,

`두 번째 파라미터`로 **포함 경계를 가진 도형을 명시**해야 한다.

`P6`를 반드시 제거해야 하는 경우에는 `ST_Contains()` 비교 결과에 대해

`ST_Distance_Sphere()` 함수를 이용해 **한 번 더 필터링**을 해야 한다.


```sql
mysql> SELECT * FROM tb_location
       WHERE ST_Contains(사각상자, px) -- 공간 좌표 px가 사각 상자에 포함되는지 비교
             AND ST_Distance_Sphere(p, px) <= 5*1000 /* 5km */
```
