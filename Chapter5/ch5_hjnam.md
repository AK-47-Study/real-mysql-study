# 05 트랜잭션과 잠금

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/eb0b3d20-41dc-4b8f-bf6f-dcf7fb6134e5)


`트랜잭션`은 작업의 완전성, 즉 `데이터의 정합성을 보장`해 주는 것이다. 

논리적인 작업 셋을 모두 완벽히 처리하거나, 처리하지 못할 경우 원 상태로 복구해서 작업의 일부만 적용되는 현상을 방지하는 기능이다.

`잠금(Lock)`은 `동시성을 제어`하기 위한 기능이다. 

하나의 레코드를 여러 커넥션에서 동시에 변경할 수 있다면 해당 레코드의 값을 예측할 수 없다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.

`격리 수준`은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 `작업 내용을 어떻게 공유하고 차단할 것인지`를 결정하는 레벨이다.

## 5.1 트랜잭션

트랜잭션은 개발자에게 큰 혜택을 제공한다. MyISAM이나 MEMORY 같이 트랜잭션을 지원하지 않는 스토리지 엔진과 트랜잭션을 지원하는 InnoDB를 비교해보자.

### 5.1.1 MySQL에서의 트랜잭션

`트랜잭션`은 쿼리의 조합이나 쿼리의 개수와 관계없이 논리적인 작업 셋 자체가 `전부 적용`되거나 `아무것도 적용되지 않아야 함을 보장`해주는 것이다. 

트랜잭션 관점에서 InnoDB 테이블과 MyISAM 테이블의 차이를 살펴보자. 

```jsx
mysql> CREATE TABLE tab_myisam ( fdpk INT NOT NULL, PRIMARY KEY (fdpk) ) ENGINE = MyISAM;
mysql> INSERT INTO tab_myisam (fdpk) VALUES (3);

mysql> CREATE TABLE tab_innodb ( fdpk INT NOT NULL, PRIMARY KEY (fdpk) ) ENGINE = INNODB;
mysql> INSERT INTO tab_innodb (fdpk) VALUES (3);
```

테스트 데이터를 저장하고 AUTO-COMMIT 모드에서 다음 쿼리문을 실행해보자.

```jsx
mysql> SET autocommit=ON;

mysql> INSERT INTO tab_myisam (fdpk) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'tab_myisam.PRIMARY'

mysql> INSERT INTO tab_innodb (fdpk) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'tab_innodb.PRIMARY'
```

두 스토리지 엔진의 결과는 `‘PK 중복 오류’로 쿼리가 실패`했다. 하지만 테이블을 살펴보면 다른 것을 볼 수 있다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/dcf880ab-e3eb-4cfd-9918-7c2ae22c6612)


MyISAM 테이블은 오류가 발생했음에도 `1, 2가 INSERT된 상태`로 남아있다.

이는 1, 2를 저장하고 3을 저장하는 순간 오류가 발생했음을 의미한다. 오류가 발생했지만 MyISAM 테이블은 1과 2는 그대로 두고 쿼리 실행을 종료해 버린 것이다. 이는 MEMORY 스토리지 엔진을 사용하는 테이블에서도 마찬가지다. 이런 `Partial Update`는 `데이터의 정합성`을 맞추는 데 상당히 어려운 문제를 만들어내는 주범이다. 

Partial Update가 발생하면 재처리가 필요할 수 있다. 간단한 경우라면 쉽겠지만 쿼리가 복잡해질수록 재처리 작업은 더 어려워진다. 

반면에 InnoDB 스토리지 엔진을 사용하는 테이블은 `쿼리가 실행되기 전 상태`로 남아있다.

쿼리 중 일부라도 `오류가 발생하면 전체를 원 상태`로 만든다는 트랜잭션의 원칙 덕분이다. 

```jsx
// 트랜잭션이 없는 경우

INSERT INTO tab_a ...;
IF(_is_insert1_succeed){
	INSERT INTO tab_b ...;
	IF(_is_insert2_succeed){
		// 처리 완료
	}ELSE{
		DELETE FROM tab_a WHERE ...;
		IF(_is_delete_succeed){
			// 처리 실피 맻 모두 원복
		}ELSE{
			// 해결 불가능한 상황
			// ...?
		}
	}
}
```

```jsx
// 트랜잭션을 지원하는 경우

try {
	START TRANSACTION;
	INSERT INTO tab_a ...;
	INSERT INTO tab_b ...;
	COMMIT;
} catch(exception) {
	ROLLBACK;
}
```

트랜잭션이 지원되는 InnoDB를 사용한다면 아주 깔끔한 코드로 해결이 가능하다. 

### 5.1.2 주의사항

트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 `최소의 코드에만 적용`하는 것이 좋다.

이는 `프로그램 코드에서 트랜잭션 범위를 최소화`하라는 의미이다. 

```jsx
1. 처리 시작
	=> 데이터베이스 커넥션 생성
	=> 트랜잭션 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장
	<= 트랜잭션 종료(COMMIT)
	<= 데이터베이스 커넥션 반납
10. 처리 완료
```

```jsx
1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 발생 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
	=> 데이터베이스 커넥션 생성 (또는 커넥션 풀에서 가져오기)
	=> 트랜잭션 시작
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
	<= 트랜잭션 종료(COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
	=> 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장
	<= 트랜잭션 종료(COMMIT)
	<= 데이터베이스 커넥션 종료(또는 커넥션 풀에 반납)
10. 처리 완료
```

왼쪽에서 실제로 DBMS에 데이터를 저장하는 작업으로 트랜잭션을 사용하는 부분은 5번부터 시작이다. 

따라서 4번 이전의 코드는 트랜잭션에 포함시킬 필요가 없다.

8번 작업처럼 메일이나 파일 전송, 원격 서버와 통신하는 작업 등은 트랜잭션 내에서 제거하는 것이 좋다. 해당 작업들에 문제가 생긴다면 웹 서버 뿐만 아니라 DBMS 서버까지 위험해질 수 있다.

오른쪽은 이런 내용을 고려하여 재설계한 것이다. 이처럼 `코드가 데이터베이스 커넥션을 가지는 범위`와 `트랜잭션이 활성화되어 있는 프로그램의 범위`를 `최소화`해야 한다. 특히, 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다. 

## 5.2 MySQL 엔진의 잠금

`MySQL에서의 잠금`은 `스토리지 엔진 레벨`과 `MySQL 레벨`로 나눌 수 있다.

MySQL 엔진은 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분이다. MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만 반대의 경우는 성립하지 않는다. 

`MySQL 엔진`에서는 `테이블 데이터 동기화`를 위한 `테이블 락`, `테이블의 구조`를 잠그는 `메타데이터 락`, `사용자의 필요`에 맞게 사용하는 `네임드 락` 기능을 제공한다. 

### 5.2.1 글로벌 락

`GLOBAL LOCK`은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다. 

MySQL에서 제공하는 `가장 큰 범위의 락`이며, MySQL 서버 전체에 영향을 미친다. 작업 대상 테이블이나 데이터베이스가 달라도 동일하게 영향을 받는다. 

한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL, DML 문장이 해제 전까지 대기 상태가 된다. 

MySQL 서버 업그레이드로 InnoDB 스토리지 엔진 사용이 일반화되고 8.0부터는 기본 스토리지 엔진이 되었다. 

InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다. `조금 더 가벼운 글로벌 락`의 필요성이 생겼고, `백업 락`이 도입되었다. 

특정 세션에서 백업 락을 획득하면 모든 세션에서 다음 내용을 할 수 없다.

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

하지만  백업 락은 일반적인 테이블의 데이터 변경은 허용한다. 

6~7시간 동안 백업이 실행되고 있는데, 갑자기 DDL 명령 하나로 인해 백업이 실패하면 다시 그만큼 시간을 들여서 백업을 실행해야 한다. MySQL 서버의 백업 락은 이런 목적으로 도입됐으며, 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.

### 5.2.2 테이블 락

테이블 락(Table Lock)은 개별 테이블 단위로 설정되는 잠금이다. 명시적 or 묵시적으로 획득할 수 있다. 

명시적으로는 `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 획득한다. 

명시적으로 획득한 잠금은 `UNLOCK TABLES` 명령으로 `잠금을 반납(해제)`한다. 

명시적 테이블 락도 특별한 상황이 아니라면 사용할 필요가 거의 없다. 글로벌 락과 마찬가지로 온라인 작업에 상당한 영향을 미치기 때문이다.

`묵시적 테이블 락`은 `MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리`를 실행하면 발생한다. 

데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제한다.

요약하자면, 쿼리 실행 시 자동으로 획득하고 완료 시 해제되는 것이다.

InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하므로 단순 데이터 변경 쿼리로 묵시적 테이블 락이 설정되지 않는다. 정확히는 테이블 락이 설정되기는 하지만 대부분의 데이터 변경 쿼리에서는 묵시적 테이블 락이 무시되고, 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 받는다.

### 5.2.3 네임드 락

네임드 락은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.

네임드 락의 특징은 대상이 데이터베이스 객체가 아니라는 점이다. 

단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다. 자주 사용되지는 않는다. 

### 5.2.4 메타데이터 락

메타데이터 락(Metadata Lock)은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.

명시적으로 획득하는 것이 아닌 데이터베이스 객체의 이름, 구조 변경시 자동으로 획득한다. 

RENAME TABLE 명령의 경우 원본 이름과 변경될 이름 모두 잠금을 설정한다.

## 5.3 InnoDB 스토리지 엔진 잠금(166)

InnoDB 스토리지 엔진은 스토리지 엔진 내부에서 `레코드 기반의 잠금 방식을 탑재`하고 있다. 이는 MySQL에서 제공하는 잠금과는 별개이다. 덕분에 `뛰어난 동시성 처리`를 제공한다. 

하지만 이원화된 잠금 처리는 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보 접근을 까다롭게 만든다. 

이전 버전에서 `InnoDB 잠금 정보를 진단할 수 있는 도구`는 `lock_monitor`와 `SHOW ENGINE INNODB STATUS 명령`이 전부였다. 

최근 버전에는 InnoDB의 트랜잭션과 잠금, 잠금 대기 중인 트랜잭션 목록을 조회하는 방법이 생겼다. 

`information_schema` 데이터베이스에 존재하는 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블을 조인해서 조회하면 된다. 

`Performance Schema`를 이용해 InnoDB 스토리지 엔진의 `내부 잠금(세마포어)에 대한 모니터링` 방법도 추가되었다. 

### 5.3.1 InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진의 `레코드 기반 잠금 기능`은 그 정보가 `상당히 작은 공간으로 관리`된다.

때문에 레코드 락이 페이지 락이나 테이블 락으로 레벨업(`락 에스컬레이션`)되는 경우는 `없다`.

InnoDB 스토리지 엔진에는 `레코드와 레코드 사이의 간격`을 잠그는 `갭 락(GAP LOCK)`이 있다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/acb41fe6-2be6-4938-b8f8-a79d7dd36b21)


**5.3.1.1 레코드 락**

레코드 락(Record Lock, Record Only Lock)은 `레코드 자체만`을 잠그는 것이다. 

중요한 점은 InnoDB 스토리지 엔진은 `레코드 자체가 아니라 인덱스의 레코드를 잠근다`는 것이다.

인덱스가 전혀 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용한다.

InnoDB에서 `보조 인덱스를 이용한 변경 작업`은 `넥스트 키 락(Next Key Lock)` 또는 `갭 락(Gap Lock)`을 사용한다. 하지만, `프라이머리 키 또는 유니크 인덱스에 의한 변경 작업`은 `레코드 자체에 대해서만 락`을 건다.

**5.3.1.2 갭 락**

갭 락(Gap Lock)은 레코드 자체가 아닌 `레코드와 바로 인접한 레코드 사이의 간격`만을 잠그는 것이다.

해당 `간격에 새로운 레코드가 생성(INSERT)되는 것을 제어`하는 역할을 한다. 주로 `넥스트 키 락의 일부로 사용`된다.

**5.3.1.3 넥스트 키 락**

넥스트 키 락(Next Key Lock)은 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다.

STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버는 REPEATABLE READ 격리 수준을 사용해야 한다. 또한 innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화(0)되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.

- GPT의 자세한 설명
    
    ### **바이너리 로그(Binary Log)와 STATEMENT 포맷**
    
    - **`바이너리 로그`**는 MySQL 서버에서 발생하는 `모든 변경`(INSERT, UPDATE, DELETE 등)을 `기록하는 로그 파일`입니다. 이 로그는 데이터 복제(Replication), 데이터 복구, 변경 사항의 감사 등 다양한 용도로 사용됩니다.
    - **`STATEMENT 포맷`**은 `바이너리 로그가 SQL 문(statement)의 형태로 변경 사항을 기록하는 방식`입니다. 즉, 어떤 SQL 명령어가 실행되었는지 `그 명령어 자체를 로그에 저장`합니다. 이 방식은 상대적으로 로그의 크기를 작게 유지할 수 있지만, 모든 상황에서 완벽하게 복제가 가능한 것은 아닙니다. 예를 들어, 난수 생성 함수나 현재 시간을 반환하는 함수가 포함된 SQL 문은 재실행 시 다른 결과를 생성할 수 있습니다.
    
    ### **REPEATABLE READ 격리 수준**
    
    - **REPEATABLE READ**는 MySQL에서 기본적으로 사용되는 트랜잭션 격리 수준입니다. 이 수준에서는 `하나의 트랜잭션 내에서 조회한 데이터를 다시 조회했을 때 동일한 결과를 보장`합니다. 즉, 한 트랜잭션 동안 같은 데이터에 대한 일관된 조회 결과를 얻을 수 있습니다.
    - 이 격리 수준을 사용하면 `다른 트랜잭션이 데이터를 변경`하더라도, `현재 진행 중인 트랜잭션에서는 변경 전 데이터를 계속 조회`할 수 있습니다. 이는 `데이터의 일관성을 유지`하지만, 다른 트랜잭션에서 변경한 `최신 데이터를 즉시 반영하지 않는다`는 의미도 있습니다.
    
    ### **innodb_locks_unsafe_for_binlog 시스템 변수와 넥스트 키 락(Next-Key Lock)**
    
    - **`innodb_locks_unsafe_for_binlog`** 시스템 변수는 일부 최적화를 활성화하여 `잠금을 줄이`지만, 바이너리 로깅에 안전하지 않은 오퍼레이션을 허용할 수 있습니다. 이 변수가 비활성화(0)된 상태는 `데이터 일관성과 복제의 정확성을 우선시`하는 설정입니다.
    - **`넥스트 키 락(Next-Key Lock)`**은 InnoDB 스토리지 엔진에서 사용하는 잠금 방식 중 하나입니다. 이 잠금 방식은 인덱스 레코드와 해당 레코드의 갭(Gap) 양쪽에 잠금을 걸어, `팬텀 리드(Phantom Read) 문제를 방지`합니다. 팬텀 리드란 `한 트랜잭션에서 반복된 조회` 사이에 `다른 트랜잭션이 새로운 레코드를 삽입`할 때, `첫 번째 트랜잭션의 조회 결과가 변경되는 현상`입니다.
    - 따라서, **innodb_locks_unsafe_for_binlog**가 0으로 설정되어 있으면, 변경을 위해 검색하는 레코드에 넥스트 키 락 방식으로 잠금이 걸립니다. 이는 `높은 수준의 데이터 일관성을 보장`하면서 바이너리 로그와 복제의 정확성을 유지하는 데 필수적입니다.

넥스트 키 락의 주목적은 `바이너리 로그에 기록되는 쿼리`가 `레플리카 서버에서 실행`될 때, `소스 서버의 결과`와 `동일한 결과`를 만드는 것을 `보장`하는 것이다.

의외로 `넥스트 키 락이나 갭 락 때문에 데드락이 발생`하거나 `다른 트랜잭션을 기다리게` 만드는 일이 자주 발생한다.

가능하면 바이너리 로그 포맷을 ROW 형태로 만들어 두 락을 줄이는 것이 좋다.

**5.3.1.4 자동 증가 락**

자동 증가 락(Auto Increment Lock)은 테이블 수준의 잠금으로, AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 새로운 레코드를 저장하는 쿼리가 요청된 경우, 중복없이 순서대로 증가할 수 있도록 하는 역할이다.

새로운 레코드를 저장하는 쿼리(INSERT, REPLACE 등)에서만 필요하며, UPDATE나 DELETE 등에는 걸리지 않는다. 

`트랜잭션과 관계없이` 쿼리에서 `AUTO_INCREMENT 값을 가져오는 순간만 락`이 걸리고 `즉시 해제`된다.

자동 증가 락을 명시적으로 획득, 해제하는 방법은 없다. 대부분의 경우 문제를 일으키지 않는다. 

5.0 이하 버전까지는 그랬다. 5.1 이상 버전부터는 `innodb_autoinc_lock_mode` 시스템 변수를 이용해 자동 증가 락 `작동 방식을 변경`할 수 있다.

- innodb_autoinc_lock_mode = `0`
    - 모든 INSERT 문장은 자동 증가 락을 사용(MySQL 5.0과 동일한 잠금 방식)
- innodb_autoinc_lock_mode = `1` (5.7 까지의 기본값)
    
- innodb_autoinc_lock_mode = `2` (8.0부터의 기본값)
    

자동 증가 값이 `한 번 증가하면 절대 줄어들지 않는 이유`가 `AUTO_INCREMENT 잠금을 최소화`하기 위해서다.
설령 INSERT 쿼리가 실패했더라도 `한 번 증가된 AUTO_INCREMENT 값`은 다시 `줄어들지 않고 그대로` 남는다.

### 5.3.2 인덱스와 잠금

InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있다. 

InnoDB의 잠금은 레코드가 아닌 인덱스를 잠그는 방식이다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다. 

위 예제에서 업데이트를 위해 몇 개의 레코드에 락을 걸어야 할까?

업데이트 쿼리 조건 부분에서 인덱스를 이용할 수 있는 조건은 first_name=’Georgi’이며, last_name 칼럼은 인덱스에 없으므로 253건의 레코드가 모두 잠긴다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/510fe903-1ab8-42dd-9cff-0d5a1d2932ba)


UPDATE 문장을 위해 적절히 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져 한 세션에서 UPDATE 작업을 하는 중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생할 것이다.

만약 테이블에 인덱스가 하나도 없다면? 테이블을 풀 스캔해야 하므로 모든 레코드를 잠그게 된다. 

이것이 MySQL의 InnoDB에서 인덱스 설계가 중요한 이유이다.

### 5.3.3 레코드 수준의 잠금 확인 및 해제

레코드 수준 잠금은 테이블 수준 잠금보다 복잡하다.

테이블 잠금은 테이블 자체가 잠금의 대상이므로 문제의 원인 파악이 쉽다.

하지만 레코드 수준 잠금은 레코드 각각에 잠금이 걸리기 때문에 문제의 식별조차 어려울 수 있다.

예전에는 레코드 잠금에 대한 메타 정보가 없어 어려웠지만, 5.1부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능해져 확인이 가능하다. 

## 5.4 MySQL의 격리 수준

트랜잭션의 `격리 수준`(isolation level)이란 `여러 트랜잭션이 동시에 처리`될 때 특정 트랜잭션이 `다른 트랜잭션에서 변경하거나 조회하는 데이터`를 볼 수 있게 `허용할지 말지`를 결정하는 것이다. 

크게 4가지로 나뉜다.

- `READ UNCOMMITTED`
    - `DIRTY READ` 라고도 하며, 일반적인 데이터베이스에서는 거의 사용하지 않는다.
- `READ COMMITTED`
- `REPEATABLE READ`
- `SERIALIZABLE`
    - 동시성이 중요한 데이터베이스에서는 거의 사용하지 않는다.

위에서 아래로 갈수록 각 트랜잭션 간의 데이터 격리(고립) 정도가 높아지고, 동시 처리 성능은 떨어진다.

격리 수준이 높아질수록 MySQL 서버의 처리 성능이 떨어질 것 같지만 SERIALIZABLE이 아닌 이상 성능 변화는 거의 없다. 

격리 수준은 세 가지 `부정합의 문제`점과 함께 언급된다. 부정합의 문제는 격리 수준에 따라 발생 여부가 달라진다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/6540ee69-1acb-4c24-99bc-c1ae05038144)


SQL-92 또는 SQL-99 표준에 따르면 REPEATABLE READ 격리 수준에서는 PHANTOM READ가 발생할 수 있지만 InnoDB는 독특한 특성 때문에 발생하지 않는다.

대부분의 데이터베이스는 READ COMMITTED(오라클 등)나 REPEATABLE READ(MySQL 등) 중 하나를 사용한다. 

### 5.4.1 READ UNCOMMITTED

각 트랜잭션에서의 변경 내용이 COMMIT/ROLLBACK 여부와 상관없이 다른 트랜잭션에서 보인다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/cf6233fc-a5e5-4751-abf0-9c292be5f8d5)


아직 커밋하기도 전인 내용을 사용자 B는 확인할 수 있고 그것이 롤백되더라도 사용자 B는 모른다.

이처럼 트랜잭션에서 처리한 `작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상`을 `더티 리드(DIRTY READ)`라고 한다.

더티 리드는 혼란을 초래하는 정합성에 문제가 많은 격리 수준이다. RDBMS 표준에서는 격리 수준으로 인정조차 하지 않는다. 쓰지 말자.

### 5.4.2 READ COMMITTED

오라클 DBMS의 기본 격리 수준이다. 온라인 서비스에서 가장 많이 선택된다. 

커밋이 완료된 데이터만 다른 트랜잭션이 조회 가능하므로 더티 리드는 발생하지 않는다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/b97a67e2-78e7-40c3-ac58-257036a1f5df)


여기서 사용되는 게 언두 로그이다. 사용자 A의 변경사항은 테이블에 저장되고 이전 내용은 언두 로그에 백업된다. 

사용자 B가 커밋 전에 레코드를 조회하면 테이블이 아닌 언두 로그에서 레코드를 조회한다. 커밋 전이기 때문에 변경 내역에 대한 테이블에서의 조회는 격리 수준에서 막혀있다. 

커밋 이후에는 새롭게 변경된 레코드를 사용자 B도 조회가 가능해진다. 

READ COMMITTED에서 발생하는 부정합의 문제로는 `NON-REPEATABLE READ`가 있다. 

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/c560f78e-bb6c-4782-8660-2c4d51c1c696)


사용자 B가 사용자 A의 커밋 전후로 레코드를 조회하면 결과가 달라지는데 이는 하나의 트랜잭션 내에서 `똑같은 쿼리`를 실행했을 때 `항상 같은 결과`를 가져와야 한다는 `REPEATABLE READ 정합성`에 어긋나게 된다. 

일반적인 웹 프로그램에서는 문제되지 않을 수 있지만 돈과 직결된 내용이라면? 

다른 트랜잭션에서 입금과 출금 처리가 계속 진행될 때 다른 트랜잭션에서 오늘 입금된 금액의
총합을 조회한다고 가정한다면 매번 다른 금액이 조회될 것이다. 

트랜잭션 내에서의 SELECT 문장과 트랜잭션 없이 실행되는 SELECT는 차이가 있다.

READ COMMITTED 수준에서는 차이가 없다. 하지만 REPEATABLE READ 수준에서는 SELECT 쿼리도 트랜잭션 범위 내에서만 작동하여, 아무리 다른 트랜잭션에서 변경과 커밋, 롤백이 이루어져도 동일한 조회 결과를 보게 된다.

### 5.4.3 REPEATABLE READ

MySQL InnoDB 스토리지 엔진의 기본 격리 수준이다. 

바이너리 로그를 가진 MySQL 서버에서는 최소 이 격리 수준 이상을 사용해야 한다.

여기서는 NON-REPEATABLE READ 부정합이 발생하지 않는다.

InnoDB 스토리지 엔진은 트랜잭션이 롤백될 가능성에 대비해 변경 전 레코드를 언두 공간에 백업하고 값을 변경한다. 이를 MVCC(Multi Version Concurrency Control)이라고 한다.(4.2.3절)

READ COMMITTED와 언두 영억을 사용하는데 있어 차이점은 언두 영역에 백업된 레코드의 몇 번째 이전 버전까지 찾아 들어가느냐다.

모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역 백업 레코드는 이 트랜잭션 번호가 포함된다. 언두 영역 백업 데이터는 주기적으로 필요여부를 판단하여 삭제한다. 

MVCC를 보장하기 위해 실행중인 트랜잭션 중 가장 오래된 번호의 트랜잭션보다 트랜잭션 번호가 낮은 언두 영역 백업은 삭제할 수 없다.

 

MVCC는 트랜잭션 간에 격리를 유지하기 위해 사용되는 기술로, 동시에 여러 트랜잭션이 데이터에 접근할 때 발생하는 문제를 해결하기 위해 도입되었습니다. REPEATABLE READ 격리 수준에서는 특히 MVCC를 활용하여 데이터의 일관성을 유지합니다.

이 격리 수준에서는 각 트랜잭션은 시작될 때 해당 트랜잭션의 시작 시점을 나타내는 트랜잭션 번호를 할당받습니다. 이후에 해당 트랜잭션은 할당받은 번호보다 오래된 트랜잭션에 의해 변경된 데이터를 읽을 수 없습니다. 즉, 해당 트랜잭션 이전에 발생한 변경 내역은 해당 트랜잭션에게 보이지 않습니다.

하지만 가장 오래된 트랜잭션 번호 이전의 모든 언두 데이터를 보존할 필요는 없습니다. 대신, 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존되어야 합니다. 이 구간은 해당 트랜잭션이 시작될 때 할당된 트랜잭션 번호와 해당 트랜잭션의 커밋 또는 롤백 시점의 번호 사이의 구간입니다.

즉, REPEATABLE READ 격리 수준에서는 해당 트랜잭션의 시작 시점과 커밋 또는 롤백 시점 사이에 발생한 모든 변경 내역을 보장하기 위해 해당 트랜잭션 번호 구간 내의 언두 데이터를 보존합니다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/ce2df9f5-04ea-4035-812d-63873c76ba63)


사용자 A가 업데이트하고 커밋까지 했더라도, 사용자 B는 수정 전의 레코드만 조회된다. 사용자 B의 트랜잭션 번호가 사용자 A의 변경 트랜잭션의 번호보다 작기 때문이다. 

REPEATABLE READ 수준에서 발생하는 부정합 문제로는 PHANTOM READ(또는 PHANTOM ROW)가 있다.

![image](https://github.com/only-juun/real-mysql-study/assets/79013722/f922f96d-50d0-4756-8812-1e1af272db4b)


REPEATABLE READ는 두 번의 SELECT 쿼리가 똑같아야 하지만 여기서는 다르다.

`SELECT ... FOR UPDATE` 쿼리는 SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다. 그래서 언두 영역의 변경 전 데이터를 가져오는 것이 아닌 현재 레코드를 가져오게 된다. 

이처럼 다른 트랜잭셔에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 PHANTOM READ라고 한다.

### 5.4.4 SERIALIZABLE

가장 단순하면서 가장 엄격한 격리 수준이다. 덕분에 동시 처리 성능이 다른 수준에 비해 떨어진다.

InnoDB 테이블에서 순수한 SELECT 작업은 Non-locking consistent read(잠금이 필요 없는 일관된 읽기)가 실행된다. 하지만 SERIALIZABLE 수준은 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야 한다. 동시에 다른 트랜잭션은 레코드를 변경하지 못한다. 

`한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.`

덕분에 PHANTOM READ 문제가 발생하지 않는다. 하지만 굳이다. 왜냐면 `InnoDB 스토리지 엔진`에서는 `갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ가 발생하지 않는다.`
